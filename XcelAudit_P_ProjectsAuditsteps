//PROJECTS , AUDIT STEPS
//KINDLY CHECK AND REMOVE LAST THREE FUNCTIONS
// Xcel_Audit_Portal_Project
var AWS = require('aws-sdk');
AWS.config.update({ region: 'ap-south-1' });
var docClient = new AWS.DynamoDB.DocumentClient();
var lambda = new AWS.Lambda();
var cognitoidentityserviceprovider = new AWS.CognitoIdentityServiceProvider({ apiVersion: '2016-04-18' });
var uuid = require('uuid');

var Archiver = require('archiver');
var Stream = require('stream');
const s3 = new AWS.S3();

const puppeteer = require('puppeteer-core');
const chromium = require('chrome-aws-lambda');

var constants = require('constants.json');
var sqs = new AWS.SQS();

function invoke_lambda(payload, function_name, callbackFunction) {
	var params = {
		FunctionName: function_name,
		InvocationType: 'RequestResponse',
		Payload: JSON.stringify(payload),
	};
	var response = lambda.invoke(params, function(err, data) {
		if (err) {
			console.log(err, 'inside invoke_lambda: could not invoke: error stack: ' + err.stack);
		}
		else {
			if (typeof callbackFunction == 'function') callbackFunction(data);
		}
	});
}

function logErrorMsg(errMsg, params, stack, callback, callbackFn) {
	var msg = 'Lambda function name :' + process.env.AWS_LAMBDA_FUNCTION_NAME + '\n\nError message : \n' + JSON.stringify(errMsg) + '\n\nParams : \n' + JSON.stringify(params) + '\n\nStack : \n' + JSON.stringify(stack) + '\n\n Cloudwatch stream :' + process.env.AWS_LAMBDA_LOG_STREAM_NAME;
	invoke_lambda({ message: msg }, 'XcelAudit_B_P_ErrorLogs', function(data) {
		callback(errMsg);
	});
}

function auditLog(logger, message, organisation_id, client_id, project_id, callbackFunction) {
	var params = {
		FunctionName: 'XcelAudit_P_Logs',
		InvocationType: 'RequestResponse',
		Payload: JSON.stringify({ logger: logger, message: message, organisation_id: organisation_id, client_id: client_id, project_id: project_id }),
	};
	var response = lambda.invoke(params, function(err, data) {
		if (err) {
			console.log(err, 'inside invoke_lambda: could not invoke: error stack: ' + err.stack);
		}
		else {
			if (typeof callbackFunction == 'function') callbackFunction(data);
		}
	});
}

function queryDynamo(params, callback, callbackFn) {
	docClient.query(params, function(err, data) {
		if (err) {
			console.log(params, err);
			logErrorMsg(err, params, err.stack, callback, function(data) {
				callback(err);
			});
		}
		else {
			if (typeof callbackFn === 'function') {
				callbackFn(data);
			}
		}
	});
}

function insertIntoDynamo(params, callback, callbackFn) {
	docClient.put(params, function(err, data) {
		if (err) {
			logErrorMsg(err, params, err.stack, callback, function(data) {
				callback(err);
			});
		}
		else {
			if (typeof callbackFn === 'function') {
				callbackFn(data);
			}
		}
	});
}

function updateDynamoRecord(params, callback, callbackFn) {
	docClient.update(params, function(err, data) {
		if (err) {
			console.log(params, err);
			logErrorMsg(err, params, err.stack, callback, function(data) {
				callback(err);
			});
		}
		else {
			if (typeof callbackFn === 'function') {
				callbackFn(data);
			}
		}
	});
}

function scanDynamo(params, callback, callbackFn) {
	docClient.scan(params, function(err, data) {
		if (err) {
			logErrorMsg(err, params, err.stack, callback, function(data) {
				callback(err);
			});
		}
		else {
			if (typeof callbackFn === 'function') {
				callbackFn(data);
			}
		}
	});
}

function getNewLibraryIdToCreateProject(callback, callbackFn) {
	let new_id = uuid.v4();
	let checkIfLibraryExists = {
		TableName: 'XcelAudit_AuditLibraries',
		KeyConditionExpression: '#audit_library_id = :audit_library_id',
		ExpressionAttributeNames: { '#audit_library_id': 'audit_library_id' },
		ExpressionAttributeValues: { ':audit_library_id': new_id },
	};
	queryDynamo(checkIfLibraryExists, callback, function(library) {
		if (library.Count == 0) {
			callbackFn(new_id);
		}
		else {
			getNewLibraryIdToCreateProject(callback, callbackFn);
		}
	});
}

function createProject(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfLibraryExists = {
			TableName: 'XcelAudit_AuditLibraries',
			KeyConditionExpression: '#audit_library_id = :audit_library_id',
			ExpressionAttributeNames: { '#audit_library_id': 'audit_library_id' },
			ExpressionAttributeValues: { ':audit_library_id': event.audit_library_id },
		};
		queryDynamo(checkIfLibraryExists, callback, function(library) {
			if (library.Count > 0) {
				let checkIfClientExists = {
					TableName: 'XcelAudit_Clients',
					KeyConditionExpression: '#client_id = :client_id',
					ExpressionAttributeNames: { '#client_id': 'client_id' },
					ExpressionAttributeValues: { ':client_id': event.client_id },
				};
				queryDynamo(checkIfClientExists, callback, function(client) {
					if (client.Count > 0) {
						let client_projects = client.Items[0].projects;
						let checkIfProjectExists = {
							TableName: 'XcelAudit_Projects',
							IndexName: 'project_name-index',
							KeyConditionExpression: '#project_name = :project_name',
							ExpressionAttributeNames: { '#project_name': 'project_name' },
							ExpressionAttributeValues: { ':project_name': event.project_name },
						};
						queryDynamo(checkIfProjectExists, callback, function(project) {
							if (project.Count == 0) {
								let checkIfUserExists = {
									TableName: 'XcelAudit_UserPortal_Users',
									IndexName: 'user_email_id-index',
									KeyConditionExpression: '#user_email_id = :user_email_id',
									FilterExpression: 'user_type = :user_type',
									ExpressionAttributeNames: { '#user_email_id': 'user_email_id' },
									ExpressionAttributeValues: { ':user_email_id': event.creater_email_id, ':user_type': 'INTERNAL' },
								};
								queryDynamo(checkIfUserExists, callback, function(user) {
									if (user.Count > 0) {
										getNewLibraryIdToCreateProject(callback, function(new_library_id) {
											let currentTime = new Date();
											let currentOffset = currentTime.getTimezoneOffset();
											let ISTOffset = 330;
											let created_at = new Date(currentTime.getTime() + (ISTOffset + currentOffset) * 60000);
											let timeStamp = created_at.getTime();
											let newProjectParams = {
												Item: {
													project_id: uuid.v4(),
													project_name: event.project_name,
													client_id: event.client_id,
													client_name: client.Items[0].client_name,
													client_code: client.Items[0].client_code,
													state: client.Items[0].state,
													zip_code: client.Items[0].zip_code,
													country: client.Items[0].country,
													Address: client.Items[0].Address,
													project_start_date: event.project_start_date,
													target_closure_date: event.target_closure_date,
													selected_template_name: library.Items[0].audit_library_name,
													selected_template_id: new_library_id,
													general_template_id: event.audit_library_id,
													project_activities: event.project_activities,
													creater_email_id: event.creater_email_id,
													project_status: 'UNDER_CREATION',
													QCP: '',
													QCP_id: '',
													TSR: '',
													project_progress: "0%",
													completed_weightage: 0,
													library_weightage: library.Items[0].library_weightage,
													EP: user.Items[0].user_name,
													EP_id: user.Items[0].user_id,
													project_members: [{
														user_email_id: event.creater_email_id,
														user_id: user.Items[0].user_id,
														user_type: 'INTERNAL',
														user_name: user.Items[0].user_name,
														has_reviewer_rights: true,
														has_archival_rights: true,
														has_assigning_step_rights: true,
														has_manage_member_rights: true,
														member_status: 'ACTIVE',
													}, ],
													number_of_projectMembers: 1,
													organisation_id: client.Items[0].organisation_id,
													created_at: timeStamp,
												},
												TableName: 'XcelAudit_Projects',
												ConditionExpression: 'attribute_not_exists(project_id)',
												ReturnValues: 'ALL_OLD',
											};
											insertIntoDynamo(newProjectParams, callback, function(InsertedData) {
												client_projects.push(newProjectParams.Item.project_id);
												let updateClientParams = {
													TableName: 'XcelAudit_Clients',
													Key: {
														client_id: event.client_id,
													},
													UpdateExpression: 'set projects = :projects',
													ExpressionAttributeValues: { ':projects': client_projects },
													ReturnValues: 'UPDATED_NEW',
												};
												updateDynamoRecord(updateClientParams, callback, function(data) {
													let getSuperAdmins = {
														TableName: 'XcelAudit_UserPortal_Users',
														IndexName: 'user_type-index',
														KeyConditionExpression: '#organisation_id = :organisation_id and #user_type = :user_type',
														ExpressionAttributeNames: {
															'#organisation_id': 'organisation_id',
															'#user_type': 'user_type',
														},
														FilterExpression: 'user_status = :user_status',
														ExpressionAttributeValues: {
															':organisation_id': event.organisation_id,
															':user_type': 'INTERNAL',
															':user_status': 'SUPER_ADMIN',
														},
													};
													queryDynamo(getSuperAdmins, callback, function(Users) {
														if (Users.Count > 0) {
															let superAdmins = Users.Items;
															let total_superAdmins = superAdmins.length;
															superAdmins.forEach((admin) => {
																let projects = admin.projects;
																projects.push(newProjectParams.Item.project_id);
																let updateSuperAdminParams = {
																	TableName: 'XcelAudit_UserPortal_Users',
																	Key: {
																		user_id: admin.user_id,
																	},
																	UpdateExpression: 'set projects = :projects',
																	ExpressionAttributeValues: { ':projects': projects },
																	ReturnValues: 'UPDATED_NEW',
																};
																updateDynamoRecord(updateSuperAdminParams, callback, function(data) {
																	total_superAdmins = total_superAdmins - 1;
																	if (total_superAdmins == 0) {
																		let updateParentLibraryStatusParams = {
																			TableName: 'XcelAudit_AuditLibraries',
																			Key: {
																				audit_library_id: event.audit_library_id,
																			},
																			UpdateExpression: 'set is_used = :is_used',
																			ExpressionAttributeValues: { ':is_used': true },
																			ReturnValues: 'UPDATED_NEW',
																		};
																		updateDynamoRecord(updateParentLibraryStatusParams, callback, function(data) {
																			auditLog(event.creater_email_id.trim(), 'Created Project for Client - ' + client.Items[0].client_name, event.organisation_id, event.client_id, newProjectParams.Item.project_id, function(value) {
																				callback(null, { status: 'Success', Status_Message: 'Project Added Successfully!!' });
																			});
																		});
																	}
																});
															});
														}
													});
												});
											});
										});
									}
									else {
										callback(new Error('EP with email ID: ' + event.creater_email_id + ' not found!!'));
									}
								});
							}
							else {
								callback(new Error('Project with name: ' + event.project_name + ' already Exists!!'));
							}
						});
					}
					else {
						callback(new Error('Client with ID: ' + event.client_id + " doesn't exist!"));
					}
				});
			}
			else {
				callback(new Error('Library With ID: ' + event.library_id + " doesn't Exist"));
			}
		});
	}
	else {
		callback(new Error('Empty Fields Found!!! Cannot create Project'));
	}
}

function listProjectsWithIDs(event, context, callback) {
	let total_projectsToFetch = event.projects.length;
	if (total_projectsToFetch > 0) {
		let promise_array = [];
		for (let i = 0; i < event.projects.length; i++) {
			promise_array.push(
				new Promise((resolve, reject) => {
					let getProject = {
						TableName: 'XcelAudit_Projects',
						KeyConditionExpression: '#project_id = :project_id',
						ExpressionAttributeNames: { '#project_id': 'project_id' },
						FilterExpression: 'project_status  <> :project_status',
						ExpressionAttributeValues: { ':project_id': event.projects[i], ':project_status': 'ARCHIVED' },
					};
					queryDynamo(getProject, callback, function(data) {
						resolve(data.Items);
					});
				})
			);
		}
		Promise.all(promise_array).then((data) => {
			data = data.flat();
			if (data.length > 0) {
				data.sort((a, b) => b.created_at - a.created_at);
				callback(null, { status: 'SUCCESS', data });
			}
			else {
				callback(new Error("There are No projects to list for you!!"));
			}
		});
	}
	else {
		callback(new Error('There are No projects to list for you!!'));
	}
}

function listProjectsForClient(event, context, callback) {
	if (event.client_id.trim().length != 0) {
		let getClientDetails = {
			TableName: 'XcelAudit_Clients',
			KeyConditionExpression: '#client_id = :client_id',
			ExpressionAttributeNames: { '#client_id': 'client_id' },
			ExpressionAttributeValues: { ':client_id': event.client_id },
		};
		queryDynamo(getClientDetails, callback, function(Client) {
			if (Client.Count > 0) {
				let response = {};
				let projects = Client.Items[0].projects;
				if (projects.length > 0) {
					response.items = projects;
					if (Client.LastEvaluatedKey != undefined && Client.LastEvaluatedKey != null) {
						response.next_token = Buffer.from(JSON.stringify(Client.LastEvaluatedKey)).toString('base64');
					}
					callback(null, {
						status: 'SUCCESS',
						data: response,
					});
				}
				else {
					callback(new Error('There are No projects for the client ' + Client.Items[0].client_name));
				}
			}
			else {
				callback(new Error('Client with ID: ' + event.client_id + " doesn't Exist"));
			}
		});
	}
	else {
		callback(new Error('Kindly Enter Client ID to list Projects'));
	}
}

function listArchivedProjects(event, context, callback) {
	if (event.creater_email_id.trim().length != 0) {
		let getProjects = {
			TableName: 'XcelAudit_Projects',
			IndexName: 'creater_email_id-index',
			KeyConditionExpression: '#creater_email_id = :creater_email_id',
			ExpressionAttributeNames: { '#creater_email_id': 'creater_email_id' },
			FilterExpression: 'project_status  = :project_status',
			ExpressionAttributeValues: { ':creater_email_id': event.creater_email_id, ':project_status': 'ARCHIVED' },
		};
		queryDynamo(getProjects, callback, function(data) {
			if (data.Count > 0) {
				let response = {};
				response.items = data.Items;
				if (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {
					response.next_token = Buffer.from(JSON.stringify(data.LastEvaluatedKey)).toString('base64');
				}
				callback(null, {
					status: 'SUCCESS',
					data: response,
				});
			}
			else {
				callback(new Error('Currently there are no archived projects!!!'));
			}
		});
	}
	else {
		callback(new Error('Kindly Enter Creater Email_Id to get list of Projects'));
	}
}

function listStagesOfProjectLibrary(event, context, callback) {
	if (event.audit_library_id.trim().length != 0) {
		let checkIfAuditLibraryExists = {
			TableName: 'XcelAudit_AuditLibraries',
			KeyConditionExpression: '#audit_library_id = :audit_library_id',
			ExpressionAttributeNames: { '#audit_library_id': 'audit_library_id' },
			ExpressionAttributeValues: { ':audit_library_id': event.audit_library_id },
		};
		queryDynamo(checkIfAuditLibraryExists, callback, function(library) {
			if (library.Count > 0) {
				let getAllAuditLibraryStages = {
					TableName: 'XcelAudit_Stages_And_Substages',
					IndexName: 'audit_library_id-type-index',
					KeyConditionExpression: '#audit_library_id = :audit_library_id AND #type = :type',
					ExpressionAttributeNames: {
						'#audit_library_id': 'audit_library_id',
						'#type': 'type',
					},
					ExpressionAttributeValues: {
						':audit_library_id': event.audit_library_id,
						':type': 'STAGE',
					},
				};
				queryDynamo(getAllAuditLibraryStages, callback, function(stages) {
					if (stages.Count > 0) {
						let response = {};
						let audit_library_stages = stages.Items;
						for (let i = 0; i < audit_library_stages.length - 1; i++) {
							for (let j = 0; j < audit_library_stages.length - 1 - i; j++) {
								if (audit_library_stages[j].stage_created_on > audit_library_stages[j + 1].stage_created_on) {
									let temp = audit_library_stages[j];
									audit_library_stages[j] = audit_library_stages[j + 1];
									audit_library_stages[j + 1] = temp;
								}
							}
						}
						response.audit_library_stages = audit_library_stages;
						if (library.LastEvaluatedKey != undefined && library.LastEvaluatedKey != null) {
							response.next_token = Buffer.from(JSON.stringify(library.LastEvaluatedKey)).toString('base64');
						}
						callback(null, {
							status: 'SUCCESS',
							data: response,
						});
					}
					else {
						callback(new Error('Kindly, Create Stages to list them'));
					}
				});
			}
			else {
				callback(new Error('Audit Library with id : ' + event.audit_library_id + ' not found!'));
			}
		});
	}
	else {
		callback(new Error('Kindly Enter Audit Library Id to list the stages and sub stages'));
	}
}

function listSubstagesOfProjectLibrary(event, context, callback) {
	if (event.audit_library_id.trim().length != 0 && event.stage_id.trim().length != 0) {
		let checkIfAuditLibraryExists = {
			TableName: 'XcelAudit_AuditLibraries',
			KeyConditionExpression: '#audit_library_id = :audit_library_id',
			ExpressionAttributeNames: { '#audit_library_id': 'audit_library_id' },
			ExpressionAttributeValues: { ':audit_library_id': event.audit_library_id },
		};
		queryDynamo(checkIfAuditLibraryExists, callback, function(library) {
			if (library.Count > 0) {
				let getAllAuditLibrarySubStages = {
					TableName: 'XcelAudit_Stages_And_Substages',
					IndexName: 'audit_library_id__parent_stage_id-type-index',
					KeyConditionExpression: '#audit_library_id__parent_stage_id = :audit_library_id__parent_stage_id AND #type = :type',
					ExpressionAttributeNames: {
						'#audit_library_id__parent_stage_id': 'audit_library_id__parent_stage_id',
						'#type': 'type',
					},
					ExpressionAttributeValues: {
						':audit_library_id__parent_stage_id': event.audit_library_id + '__' + event.stage_id,
						':type': 'SUB_STAGE',
					},
				};
				queryDynamo(getAllAuditLibrarySubStages, callback, function(stages) {
					if (stages.Count > 0) {
						let response = {};
						let audit_library_stages = stages.Items;
						for (let i = 0; i < audit_library_stages.length - 1; i++) {
							for (let j = 0; j < audit_library_stages.length - 1 - i; j++) {
								if (audit_library_stages[j].stage_created_on > audit_library_stages[j + 1].stage_created_on) {
									let temp = audit_library_stages[j];
									audit_library_stages[j] = audit_library_stages[j + 1];
									audit_library_stages[j + 1] = temp;
								}
							}
						}
						response.audit_library_stages = audit_library_stages;
						if (library.LastEvaluatedKey != undefined && library.LastEvaluatedKey != null) {
							response.next_token = Buffer.from(JSON.stringify(library.LastEvaluatedKey)).toString('base64');
						}
						callback(null, {
							status: 'SUCCESS',
							data: response,
						});
					}
					else {
						callback(new Error('Kindly, Create Stages to list them'));
					}
				});
			}
			else {
				callback(new Error('Audit Library with id : ' + event.audit_library_id + ' not found!'));
			}
		});
	}
	else {
		callback(new Error('Kindly Enter Audit Library Id  and Stage ID to list the sub stages'));
	}
}

function listStepsForSubstageOfProjectLibrary(event, context, callback) {
	if (event.audit_library_id.trim().length != 0 && event.sub_stage_id.trim().length != 0) {
		let checkIfAuditLibraryExists = {
			TableName: 'XcelAudit_AuditLibraries',
			KeyConditionExpression: '#audit_library_id = :audit_library_id',
			ExpressionAttributeNames: { '#audit_library_id': 'audit_library_id' },
			ExpressionAttributeValues: { ':audit_library_id': event.audit_library_id },
		};
		queryDynamo(checkIfAuditLibraryExists, callback, function(library) {
			if (library.Count > 0) {
				let getAllAuditLibrarySteps = {
					TableName: 'XcelAudit_Library_Steps',
					IndexName: 'sub_stage_id-index',
					KeyConditionExpression: '#sub_stage_id = :sub_stage_id',
					ExpressionAttributeNames: {
						'#sub_stage_id': 'sub_stage_id',
					},
					ExpressionAttributeValues: {
						':sub_stage_id': event.sub_stage_id,
					},
				};
				queryDynamo(getAllAuditLibrarySteps, callback, function(steps) {
					if (steps.Count > 0) {
						let response = {};
						let audit_library_steps = steps.Items;
						for (let i = 0; i < audit_library_steps.length - 1; i++) {
							for (let j = 0; j < audit_library_steps.length - 1 - i; j++) {
								if (audit_library_steps[j].step_added_at > audit_library_steps[j + 1].step_added_at) {
									let temp = audit_library_steps[j];
									audit_library_steps[j] = audit_library_steps[j + 1];
									audit_library_steps[j + 1] = temp;
								}
							}
						}
						response.audit_library_steps = audit_library_steps;
						if (library.LastEvaluatedKey != undefined && library.LastEvaluatedKey != null) {
							response.next_token = Buffer.from(JSON.stringify(library.LastEvaluatedKey)).toString('base64');
						}
						callback(null, {
							status: 'SUCCESS',
							data: response,
						});
					}
					else {
						callback(new Error('Kindly, Create Stages to list them'));
					}
				});
			}
			else {
				callback(new Error('Audit Library with id : ' + event.audit_library_id + ' not found!'));
			}
		});
	}
	else {
		callback(new Error('Kindly Enter Audit Library Id  and Stage ID to list the sub stages'));
	}
}

//check if applicablility steps are done IF NOT THEN THROW ERROR
function updateProjectStatus(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id },
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let checkIfUserExists = {
					TableName: 'XcelAudit_UserPortal_Users',
					IndexName: 'user_email_id-index',
					KeyConditionExpression: '#user_email_id = :user_email_id',
					FilterExpression: 'user_system_status = :user_system_status AND user_status = :user_status',
					ExpressionAttributeNames: { '#user_email_id': 'user_email_id' },
					ExpressionAttributeValues: {
						':user_email_id': event.creater_email_id,
						':user_system_status': 'ACTIVE',
						':user_status': 'SUPER_ADMIN',
					},
				};
				queryDynamo(checkIfUserExists, callback, function(user) {
					if (user.Count > 0) {
						if (user.Items[0].user_id == project.Items[0].EP_id) {
							let checkStatus = true;
							//let checkStatus = false;
							// let currentStatusAt;
							// let project_statuses = ['TO_BE_STARTED', 'IN_PROGRESS', 'COMPLETED', 'ARCHIVED'];
							// for (let i = 0; i < project_statuses.length; i++) {
							// 	if (project_statuses[i] == project.Items[0].project_status) {
							// 		currentStatusAt = i;
							// 	}
							// }
							// for (let i = 0; i < project_statuses.length; i++) {
							// 	if (project_statuses[i] == event.project_status) {
							// 		if (project.Items[0].project_status == 'COMPLETED' && event.project_status == 'IN_PROGRESS') {
							// 			checkStatus = true;
							// 		}
							// 		//project.Items[0].project_status
							// 		else if (project.Items[0].project_status == project_statuses[i - 1]) {
							// 			checkStatus = true;
							// 		}
							// 		else {
							// 			if (project_statuses[currentStatusAt + 1] == undefined) {
							// 				callback(new Error('Project Status Can not be updated'));
							// 			}
							// 			callback(new Error('Project Status Can Only be updated to ' + project_statuses[currentStatusAt + 1]));
							// 		}
							// 	}
							// }
							if (checkStatus) {
								let updateProjectParams = {
									TableName: 'XcelAudit_Projects',
									Key: {
										project_id: event.project_id,
									},
									UpdateExpression: 'set project_status = :project_status',
									ExpressionAttributeValues: { ':project_status': event.project_status },
									ReturnValues: 'UPDATED_NEW',
								};
								if (event.project_status == 'COMPLETED') {
									updateProjectParams.UpdateExpression = 'set project_status = :project_status,completed_on = :completed_on';
									updateProjectParams.ExpressionAttributeValues = { ':project_status': event.project_status, ':completed_on': Date.now() };
								}
								if (event.project_status == 'ARCHIVED') {
									zipProject(event.organisation_id, project.Items[0].client_id, event.project_id, project.Items[0].project_name, callback, function(data) {
										if (data == "ZIPPED") {
											let report_path = `https://xcel-audit-documents.s3.ap-south-1.amazonaws.com/${encodeURI(event.organisation_id + '/' + project.Items[0].client_id + '/' + event.project_id + '/pdf/' + project.Items[0].project_name + '.pdf')}`;
											let repository_path = `https://xcel-audit-documents.s3.ap-south-1.amazonaws.com/${encodeURI(event.organisation_id + '/' + project.Items[0].client_id + '/' + event.project_id + '/zip/' + project.Items[0].project_name + '.zip')}`;
											updateProjectParams.UpdateExpression = 'set project_status = :project_status,archived_on = :archived_on,repository_path = :repository_path,report_path = :report_path';
											updateProjectParams.ExpressionAttributeValues = {
												':project_status': event.project_status,
												':archived_on': Date.now(),
												':repository_path': repository_path,
												':report_path': report_path
											};
										}
										else if (data == "NO_DOCUMENT_FOUND") {
											let report_path = `https://xcel-audit-documents.s3.ap-south-1.amazonaws.com/${encodeURI(event.organisation_id + '/' + project.Items[0].client_id + '/' + event.project_id + '/pdf/' + project.Items[0].project_name + '.pdf')}`;
											updateProjectParams.UpdateExpression = 'set project_status = :project_status,archived_on = :archived_on,report_path = :report_path';
											updateProjectParams.ExpressionAttributeValues = {
												':project_status': event.project_status,
												':archived_on': Date.now(),
												':report_path': report_path
											};
										}
										var myvar = '<html>' + '<body> ' + ' <p><h1> Project Summary:</h1> ' + '</p>' + '</body>' + '</html > ';

										// let getAllAuditStepsParams = {

										// };
										// queryDynamo(getAllAuditStepsParams,callback,function(data){

										// });

										// var invoking_params = {
										// 	FunctionName: "XcelAudit_P_ArchivalReportGeneration",
										// 	InvocationType: 'Event',
										// 	Payload: JSON.stringify({
										// 		organisation_id: event.organisation_id,
										// 		client_id: project.Items[0].client_id,
										// 		project_id: event.project_id,
										// 		project_name: project.Items[0].project_name
										// 	}),
										// };
										// lambda.invoke(invoking_params, function(err, data) {
										// 	if (err) {
										// 		console.log(err, 'inside invoke_lambda: could not invoke: error stack: ' + err.stack);
										// 	}
										// 	else {
										// 		updateDynamoRecord(updateProjectParams, callback, function(data) {
										// 			auditLog(event.creater_email_id.trim(), 'Updated Project Status as - ' + event.project_status + 'For Project -' + project.Items[0].project_name, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
										// 				callback(null, { status: 'Success', Status_Message: ' Updated Project Status Successfully!!' });
										// 			});
										// 		});
										// 	}
										// });
										generatePDF(myvar, event.organisation_id, project.Items[0].client_id, event.project_id, project.Items[0].project_name, callback, function(data) {
											updateDynamoRecord(updateProjectParams, callback, function(data) {
												auditLog(event.creater_email_id.trim(), 'Updated Project Status as - ' + event.project_status + 'For Project -' + project.Items[0].project_name, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
													callback(null, { status: 'Success', Status_Message: ' Updated Project Status Successfully!!' });
												});
											});
										});
									});
								}
								else {
									updateDynamoRecord(updateProjectParams, callback, function(data) {
										auditLog(event.creater_email_id.trim(), 'Updated Project Status as - ' + event.project_status + 'For Project -' + project.Items[0].project_name, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
											callback(null, { status: 'Success', Status_Message: ' Updated Project Status Successfully!!' });
										});
									});
								}
							}
							else {
								callback(null, project.Items[0].project_status);
							}
						}
						else {
							callback(new Error('You Cannot updated Status as you are not EP of the project'));
						}
					}
					else {
						callback(new Error('Active Super Admin with Email: ' + event.creater_email_id + "Doesn't Exists"));
					}
				});
			}
			else {
				callback(new Error('Project with ID: ' + event.project_id + ' not found'));
			}
		});
	}
	else {
		callback(new Error('Empty Field Occured Cannot update Status'));
	}
}

// ZIPPING WILL HAPPEN WHEN PROJECT STATUS IS UPDATED AS ARCHIVED
function zipProject(organisation_id, client_id, project_id, project_name, callback, callbackFn) {
	let getFilesParams = {
		Bucket: 'xcel-audit-documents',
		Prefix: organisation_id + '/' + client_id + '/' + project_id + '/',
		//	Prefix: organisation_id + '/' + client_id + '/' + project_id + '/documents',
	};
	let getKeys = async (params) => {
		let data = await s3.listObjectsV2(params).promise();
		while (data.NextContinuationToken != undefined) {
			params.ContinuationToken = data.NextContinuationToken;
			let nextData = await s3.listObjectsV2(params).promise();
			data.Contents = data.Contents.concat(nextData.Contents);
			if (nextData.NextContinuationToken != undefined) {
				data.NextContinuationToken = nextData.NextContinuationToken;
			}
			else {
				data.NextContinuationToken = undefined;
			}
		}
		return data;
	};
	let data = getKeys(getFilesParams);
	data.then((data) => {
		console.log(data.KeyCount);
		if (data.KeyCount >= 1) {
			const streamPassThrough = new Stream.PassThrough();
			const archive = Archiver('zip', {
				zlib: { level: 0 },
			});
			archive.on('error', (error) => {
				callback(new Error(`${error.name} ${error.code} ${error.message} ${error.path}  ${error.stack}`));
			});
			archive.pipe(streamPassThrough);
			for (let i = 0; i < data.Contents.length; i++) {
				if (data.Contents[i].Size > 0) {
					const stream = s3.getObject({ Bucket: 'xcel-audit-documents', Key: data.Contents[i].Key }).createReadStream();
					archive.append(stream, { name: data.Contents[i].Key.split('/')[data.Contents[i].Key.split('/').length - 1] });
				}
			}
			archive.finalize();
			const uploadParams = {
				Bucket: 'xcel-audit-documents',
				ACL: 'public-read',
				Body: streamPassThrough,
				ContentType: 'application/zip',
				Key: organisation_id + '/' + client_id + '/' + project_id + '/zip/' + project_name + '.zip',
			};
			s3.upload(uploadParams, (err, data) => {
				if (err) console.error('upload error', err);
				else {
					if (typeof callbackFn === 'function') {
						callbackFn("ZIPPED");
					}
				}
			});
		}
		else {
			callbackFn("NO_DOCUMENT_FOUND");
		}
		// NEED MORE TEST CASES
		// else if (data.KeyCount == 1) {
		// 	callback(new Error('Currently There Are No Files Under this Project'));
		// }
		// else {
		// 	callback(new Error('Project Folder Not Found'));
		// }
	});
}

// GENERATING PDF WILL HAPPEN WHEN PROJECT STATUS IS UPDATED AS ARCHIVED
async function generatePDF(htmlFile, organisation_id, client_id, project_id, project_name, callback, callbackFn) {
	const browser = await chromium.puppeteer.launch({
		args: chromium.args,
		defaultViewport: chromium.defaultViewport,
		executablePath: await chromium.executablePath,
		headless: chromium.headless,
		ignoreHTTPSErrors: true,
	});
	const page = await browser.newPage();
	await page.setContent(htmlFile);

	const pdf = await page.pdf({ format: 'A4' });
	//path: 'invoice.pdf',
	await browser.close();
	const uploadParams = {
		Bucket: 'xcel-audit-documents',
		ACL: 'public-read',
		Body: pdf,
		ContentType: 'application/pdf',
		Key: organisation_id + '/' + client_id + '/' + project_id + '/pdf/' + project_name + '.pdf',
	};
	s3.upload(uploadParams, (err, data) => {
		if (err) console.error('upload error', err);
		else {
			if (typeof callbackFn === 'function') {
				callbackFn(data);
			}
		}
	});
}

function manageQCP(event, context, callback) {
	if (event.user_id.trim().length != 0) {
		let getQCPDetails = {
			TableName: 'XcelAudit_UserPortal_Users',
			KeyConditionExpression: '#user_id = :user_id',
			ExpressionAttributeNames: { '#user_id': 'user_id' },
			FilterExpression: 'user_system_status = :user_system_status',
			ExpressionAttributeValues: {
				':user_id': event.user_id,
				':user_system_status': 'ACTIVE',
			},
		};
		queryDynamo(getQCPDetails, callback, function(Users) {
			if (Users.Count > 0) {
				let checkIfProjectExists = {
					TableName: 'XcelAudit_Projects',
					KeyConditionExpression: '#project_id = :project_id',
					ExpressionAttributeNames: { '#project_id': 'project_id' },
					ExpressionAttributeValues: { ':project_id': event.project_id },
				};
				queryDynamo(checkIfProjectExists, callback, function(project) {
					if (project.Count > 0) {
						if (project.Items[0].EP_id != event.user_id) {
							let project_members = project.Items[0].project_members;
							let manageQCPParams = {
								TableName: 'XcelAudit_Projects',
								Key: {
									project_id: event.project_id,
								},
								UpdateExpression: 'set QCP = :QCP , QCP_id = :QCP_id',
								ExpressionAttributeValues: { ':QCP': Users.Items[0].user_name, ':QCP_id': event.user_id },
								ReturnValues: 'UPDATED_NEW',
							};
							updateDynamoRecord(manageQCPParams, callback, function(data) {
								let member_doesnot_exist = true;
								project_members.forEach((member) => {
									if (member.user_id == event.user_id) {
										member_doesnot_exist = false;
									}
								});
								if (member_doesnot_exist) {
									project_members.push({
										user_email_id: Users.Items[0].user_email_id,
										user_id: Users.Items[0].user_id,
										user_name: Users.Items[0].user_name,
										member_status: 'ACTIVE',
										user_type: 'INTERNAL',
										has_reviewer_rights: false,
									});
									let updateProjectMembersParams = {
										TableName: 'XcelAudit_Projects',
										Key: {
											project_id: event.project_id,
										},
										UpdateExpression: 'set project_members = :project_members,number_of_projectMembers=:number_of_projectMembers',
										ExpressionAttributeValues: { ':project_members': project_members, ':number_of_projectMembers': project.Items[0].number_of_projectMembers + 1 },
										ReturnValues: 'UPDATED_NEW',
									};
									updateDynamoRecord(updateProjectMembersParams, callback, function(data) {
										let user_projects = Users.Items[0].projects;
										let project_does_not_exist = true;
										user_projects.forEach((project_id) => {
											if (project_id == event.project_id) {
												project_does_not_exist = false;
											}
										});
										if (project_does_not_exist) {
											user_projects.push(event.project_id);
											let updateInternalUserParams = {
												TableName: 'XcelAudit_UserPortal_Users',
												Key: {
													user_id: Users.Items[0].user_id,
												},
												UpdateExpression: 'set projects = :projects',
												ExpressionAttributeValues: { ':projects': user_projects },
												ReturnValues: 'UPDATED_NEW',
											};
											updateDynamoRecord(updateInternalUserParams, callback, function(data) {
												auditLog(event.creater_email_id.trim(), 'Updated TSR - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
													callback(null, { status: 'Success', Status_Message: '  Updated QCP Successfully!!' });
												});
											});
										}
										else {
											auditLog(event.creater_email_id.trim(), 'Updated TSR - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
												callback(null, { status: 'Success', Status_Message: '  Updated QCP Successfully!!' });
											});
										}
									});
								}
								else {
									auditLog(event.creater_email_id.trim(), 'Updated QCP - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
										callback(null, { status: 'Success', Status_Message: '  Updated QCP Successfully!!' });
									});
								}
							});
						}
						else {
							callback(new Error('QCP cannot be same as EP'));
						}
					}
					else {
						callback(new Error('Project with id: ' + event.project_id + 'not found'));
					}
				});
			}
			else {
				callback(new Error('No ACTIVE user found with id: ' + event.user_id));
			}
		});
	}
	else {
		callback(new Error('Kindly,Enter QCP user ID to Manage QCP'));
	}
}

function manageTSR(event, context, callback) {
	if (event.user_id.trim().length != 0) {
		let getTSRDetails = {
			TableName: 'XcelAudit_UserPortal_Users',
			KeyConditionExpression: '#user_id = :user_id',
			ExpressionAttributeNames: { '#user_id': 'user_id' },
			FilterExpression: 'user_system_status = :user_system_status',
			ExpressionAttributeValues: {
				':user_id': event.user_id,
				':user_system_status': 'ACTIVE',
			},
		};
		queryDynamo(getTSRDetails, callback, function(Users) {
			if (Users.Count > 0) {
				let checkIfProjectExists = {
					TableName: 'XcelAudit_Projects',
					KeyConditionExpression: '#project_id = :project_id',
					ExpressionAttributeNames: { '#project_id': 'project_id' },
					ExpressionAttributeValues: { ':project_id': event.project_id },
				};
				queryDynamo(checkIfProjectExists, callback, function(project) {
					if (project.Count > 0) {
						let project_members = project.Items[0].project_members;
						let manageQCPParams = {
							TableName: 'XcelAudit_Projects',
							Key: {
								project_id: event.project_id,
							},
							UpdateExpression: 'set TSR = :TSR , TSR_id = :TSR_id',
							ExpressionAttributeValues: { ':TSR': Users.Items[0].user_name, ':TSR_id': event.user_id },
							ReturnValues: 'UPDATED_NEW',
						};
						updateDynamoRecord(manageQCPParams, callback, function(data) {
							let member_doesnot_exist = true;
							project_members.forEach((member) => {
								if (member.user_id == event.user_id) {
									member_doesnot_exist = false;
								}
							});
							if (member_doesnot_exist) {
								project_members.push({
									user_email_id: Users.Items[0].user_email_id,
									user_id: Users.Items[0].user_id,
									user_name: Users.Items[0].user_name,
									member_status: 'ACTIVE',
									user_type: 'INTERNAL',
									has_reviewer_rights: false,
								});
								let updateProjectMembersParams = {
									TableName: 'XcelAudit_Projects',
									Key: {
										project_id: event.project_id,
									},
									UpdateExpression: 'set project_members = :project_members,number_of_projectMembers=:number_of_projectMembers',
									ExpressionAttributeValues: { ':project_members': project_members, ':number_of_projectMembers': project.Items[0].number_of_projectMembers + 1 },
									ReturnValues: 'UPDATED_NEW',
								};
								updateDynamoRecord(updateProjectMembersParams, callback, function(data) {
									let user_projects = Users.Items[0].projects;
									let project_does_not_exist = true;
									user_projects.forEach((project_id) => {
										if (project_id == event.project_id) {
											project_does_not_exist = false;
										}
									});
									if (project_does_not_exist) {
										user_projects.push(event.project_id);
										let updateInternalUserParams = {
											TableName: 'XcelAudit_UserPortal_Users',
											Key: {
												user_id: Users.Items[0].user_id,
											},
											UpdateExpression: 'set projects = :projects',
											ExpressionAttributeValues: { ':projects': user_projects },
											ReturnValues: 'UPDATED_NEW',
										};
										updateDynamoRecord(updateInternalUserParams, callback, function(data) {
											auditLog(event.creater_email_id.trim(), 'Updated TSR - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
												callback(null, { status: 'Success', Status_Message: '  Updated TSR Successfully!!' });
											});
										});
									}
									else {
										auditLog(event.creater_email_id.trim(), 'Updated TSR - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
											callback(null, { status: 'Success', Status_Message: '  Updated TSR Successfully!!' });
										});
									}
								});
							}
							else {
								auditLog(event.creater_email_id.trim(), 'Updated TSR - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
									callback(null, { status: 'Success', Status_Message: '  Updated TSR Successfully!!' });
								});
							}
						});
					}
					else {
						callback(new Error('Project with id: ' + event.project_id + 'not found'));
					}
				});
			}
			else {
				callback(new Error('No ACTIVE user found with id: ' + event.user_id));
			}
		});
	}
	else {
		callback(new Error('Kindly,Enter QCP user ID to Manage QCP'));
	}
}

function manageEP(event, context, callback) {
	if (event.user_id.trim().length != 0) {
		let getTSRDetails = {
			TableName: 'XcelAudit_UserPortal_Users',
			KeyConditionExpression: '#user_id = :user_id',
			ExpressionAttributeNames: { '#user_id': 'user_id' },
			FilterExpression: 'user_system_status = :user_system_status',
			ExpressionAttributeValues: {
				':user_id': event.user_id,
				':user_system_status': 'ACTIVE',
			},
		};
		queryDynamo(getTSRDetails, callback, function(Users) {
			if (Users.Count > 0) {
				let checkIfProjectExists = {
					TableName: 'XcelAudit_Projects',
					KeyConditionExpression: '#project_id = :project_id',
					ExpressionAttributeNames: { '#project_id': 'project_id' },
					ExpressionAttributeValues: { ':project_id': event.project_id },
				};
				queryDynamo(checkIfProjectExists, callback, function(project) {
					if (project.Count > 0) {
						if (project.Items[0].QCP_id != event.user_id) {
							let project_members = project.Items[0].project_members;
							let manageEPParams = {
								TableName: 'XcelAudit_Projects',
								Key: {
									project_id: event.project_id,
								},
								UpdateExpression: 'set EP = :EP , EP_id = :EP_id',
								ExpressionAttributeValues: { ':EP': Users.Items[0].user_name, ':EP_id': event.user_id },
								ReturnValues: 'UPDATED_NEW',
							};
							updateDynamoRecord(manageEPParams, callback, function(data) {
								let member_doesnot_exist = true;
								project_members.forEach((member) => {
									if (member.user_id == event.user_id) {
										member_doesnot_exist = false;
									}
								});
								if (member_doesnot_exist) {
									project_members.push({
										user_email_id: Users.Items[0].user_email_id,
										user_id: Users.Items[0].user_id,
										user_name: Users.Items[0].user_name,
										member_status: 'ACTIVE',
										user_type: 'INTERNAL',
										has_reviewer_rights: false,
									});
									let updateProjectMembersParams = {
										TableName: 'XcelAudit_Projects',
										Key: {
											project_id: event.project_id,
										},
										UpdateExpression: 'set project_members = :project_members,number_of_projectMembers=:number_of_projectMembers',
										ExpressionAttributeValues: { ':project_members': project_members, ':number_of_projectMembers': project.Items[0].number_of_projectMembers + 1 },
										ReturnValues: 'UPDATED_NEW',
									};
									updateDynamoRecord(updateProjectMembersParams, callback, function(data) {
										let user_projects = Users.Items[0].projects;
										let project_does_not_exist = true;
										user_projects.forEach((project_id) => {
											if (project_id == event.project_id) {
												project_does_not_exist = false;
											}
										});
										if (project_does_not_exist) {
											user_projects.push(event.project_id);
											let updateInternalUserParams = {
												TableName: 'XcelAudit_UserPortal_Users',
												Key: {
													user_id: Users.Items[0].user_id,
												},
												UpdateExpression: 'set projects = :projects',
												ExpressionAttributeValues: { ':projects': user_projects },
												ReturnValues: 'UPDATED_NEW',
											};
											updateDynamoRecord(updateInternalUserParams, callback, function(data) {
												auditLog(event.creater_email_id.trim(), 'Updated EP - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
													callback(null, { status: 'Success', Status_Message: '  Updated EP Successfully!!' });
												});
											});
										}
										else {
											auditLog(event.creater_email_id.trim(), 'Updated EP - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
												callback(null, { status: 'Success', Status_Message: '  Updated EP Successfully!!' });
											});
										}
									});
								}
								else {
									auditLog(event.creater_email_id.trim(), 'Updated EP - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
										callback(null, { status: 'Success', Status_Message: '  Updated EP Successfully!!' });
									});
								}
							});
						}
						else {
							callback(new Error('EP cannot be same as QCP'));
						}
					}
					else {
						callback(new Error('Project with id: ' + event.project_id + 'not found'));
					}
				});
			}
			else {
				callback(new Error('No ACTIVE user found with id: ' + event.user_id));
			}
		});
	}
	else {
		callback(new Error('Kindly,Enter EP user ID to Manage EP'));
	}
}

function addProjectMember(event, context, callback) {
	if (event.project_id.trim().length != 0) {
		let getUserDetails = {
			TableName: 'XcelAudit_UserPortal_Users',
			KeyConditionExpression: '#user_id = :user_id',
			ExpressionAttributeNames: { '#user_id': 'user_id' },
			FilterExpression: 'user_system_status = :user_system_status AND user_type = :user_type',
			ExpressionAttributeValues: {
				':user_id': event.member_user_id,
				':user_system_status': 'ACTIVE',
				':user_type': event.user_type,
			},
		};
		queryDynamo(getUserDetails, callback, function(Users) {
			if (Users.Count > 0) {
				let checkIfProjectExists = {
					TableName: 'XcelAudit_Projects',
					KeyConditionExpression: '#project_id = :project_id',
					ExpressionAttributeNames: { '#project_id': 'project_id' },
					ExpressionAttributeValues: { ':project_id': event.project_id },
				};
				queryDynamo(checkIfProjectExists, callback, function(project) {
					if (project.Count > 0) {
						let correct_user = true;
						if (event.user_type == 'EXTERNAL') {
							if (Users.Items[0].client_id != project.Items[0].client_id) {
								correct_user = false;
							}
						}
						if (correct_user) {
							let existing_projectmembers_count = project.Items[0].project_members.length;
							let project_members = project.Items[0].project_members;
							let member_doesnot_exist = true;
							project_members.forEach((member) => {
								if (member.user_id == event.member_user_id) {
									member_doesnot_exist = false;
								}
							});
							if (member_doesnot_exist) {
								project_members.push({
									user_email_id: Users.Items[0].user_email_id,
									user_id: event.member_user_id,
									user_name: Users.Items[0].user_name,
									user_type: event.user_type,
									has_reviewer_rights: event.has_reviewer_rights,
									has_archival_rights: event.has_archival_rights,
									has_assigning_step_rights: event.has_assigning_step_rights,
									has_manage_member_rights: event.has_manage_member_rights,
									member_status: 'ACTIVE',
								});
							}
							if (project_members.length > existing_projectmembers_count) {
								let manageProjectParams = {
									TableName: 'XcelAudit_Projects',
									Key: {
										project_id: event.project_id,
									},
									UpdateExpression: 'set project_members=:project_members,number_of_projectMembers=:number_of_projectMembers',
									ExpressionAttributeValues: { ':project_members': project_members, ':number_of_projectMembers': project_members.length },
									ReturnValues: 'UPDATED_NEW',
								};
								updateDynamoRecord(manageProjectParams, callback, function(data) {
									let user_projects = Users.Items[0].projects;
									let project_does_not_exist = true;
									user_projects.forEach((project_id) => {
										if (project_id == event.project_id) {
											project_does_not_exist = false;
										}
									});
									if (project_does_not_exist) {
										user_projects.push(event.project_id);
										let updateInternalUserParams = {
											TableName: 'XcelAudit_UserPortal_Users',
											Key: {
												user_id: Users.Items[0].user_id,
											},
											UpdateExpression: 'set projects = :projects',
											ExpressionAttributeValues: { ':projects': user_projects },
											ReturnValues: 'UPDATED_NEW',
										};
										updateDynamoRecord(updateInternalUserParams, callback, function(data) {
											auditLog(event.creater_email_id.trim(), 'Updated TSR - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
												//SES
												callback(null, { status: 'Success', Status_Message: '  Added Member Successfully!!' });
											});
										});
									}
									else {
										auditLog(event.creater_email_id.trim(), 'Updated TSR - ' + event.user_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
											callback(null, { status: 'Success', Status_Message: '  Added Member Successfully!!' });
										});
									}
								});
							}
							else {
								callback(new Error('Project Member Already Exists!'));
							}
						}
						else {
							callback(new Error('Selected External User: ' + Users.Items[0].user_name + ' Cannot be added to this project'));
						}
					}
					else {
						callback(new Error('Project with ID: ' + event.project_id + ' not found!'));
					}
				});
			}
			else {
				callback(new Error(' No User Found!'));
			}
		});
	}
	else {
		callback(new Error('Kindly Enter Project Id to Manage Project'));
	}
}

function listProjectMembers(event, context, callback) {
	if (event.project_id.trim().length != 0) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id },
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let response = {};
				response.items = project.Items[0].project_members;
				callback(null, { status: 'SUCCESS', data: response });
			}
			else {
				callback(new Error('Project with ID: ' + event.project_id + ' not Found!!'));
			}
		});
	}
	else {
		callback(new Error('Kindly enter project id to list project members'));
	}
}

//This Function Will Get Executed When editProjectMember Fn is under execution and Removing the member
async function checkIfUserIsReviewer(project_id, user_id, callback, callbackFn) {
	let getAllSteps = {
		TableName: 'XcelAudit_Library_Steps',
		IndexName: 'project_id-index',
		KeyConditionExpression: '#project_id = :project_id',
		ExpressionAttributeNames: {
			'#project_id': 'project_id',
		},
		ExpressionAttributeValues: {
			':project_id': project_id,
		},
	};
	let data = await docClient.query(getAllSteps).promise();
	if (data.Count > 0) {
		for (let i = 0; i < data.Items.length; i++) {
			if (data.Items[i].reviewer_user_id != undefined && data.Items[i].reviewer_user_id == user_id) {
				callbackFn(true, data.Items[i]);
			}
		}
		while (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {
			let next_token = Buffer.from(JSON.stringify(data.LastEvaluatedKey)).toString('base64');
			getAllSteps.ExclusiveStartKey = JSON.parse(Buffer.from(next_token, 'base64').toString('ascii'));
			let data = await docClient.query(getAllSteps).promise();
			for (let i = 0; i < data.Count; i++) {
				if (data.Items[i].reviewer_user_id != undefined && data.Items[i].reviewer_user_id == user_id) {
					data.LastEvaluatedKey = undefined;
					callbackFn(true, data.Items[i]);
				}
			}
		}
		callbackFn(false, null);
	}
	else {
		callbackFn(false, null);
	}
}

function editProjectMember(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id },
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let project_members = project.Items[0].project_members;
				project_members.forEach((member, index) => {
					if (member.user_id == event.user_id) {
						project_members[index].has_archival_rights = event.has_archival_rights;

						if (event.member_status != undefined) {
							project_members[index].member_status = event.member_status;
						}
						if (event.has_reviewer_rights != undefined) {
							if (event.has_reviewer_rights) {

								project_members[index].has_reviewer_rights = event.has_reviewer_rights;
								project_members[index].has_assigning_step_rights = event.has_assigning_step_rights;
								project_members[index].has_manage_member_rights = event.has_manage_member_rights;

								let updateProjectParams = {
									TableName: 'XcelAudit_Projects',
									Key: {
										project_id: event.project_id,
									},
									UpdateExpression: 'set project_members=:project_members',
									ExpressionAttributeValues: { ':project_members': project_members },
									ReturnValues: 'UPDATED_NEW',
								};
								updateDynamoRecord(updateProjectParams, callback, function(data) {
									auditLog(event.creater_email_id.trim(), 'Updated Member to the Project - ' + project.Items[0].project_name, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
										callback(null, { status: 'Success', Status_Message: ' Updated Member Successfully!!' });
									});
								});
							}
							else {
								checkIfUserIsReviewer(event.project_id, event.user_id, function(is_reviewer_present, step) {
									if (is_reviewer_present) {
										callback(new Error('Cannot remove reviewer rights  as he is assigned to step ' + step.step_name + ' under subStage ' + step.sub_stage_id + ' of Stage ' + step.stage_id));
									}
									else {
										let updateProjectParams = {
											TableName: 'XcelAudit_Projects',
											Key: {
												project_id: event.project_id,
											},
											UpdateExpression: 'set project_members=:project_members',
											ExpressionAttributeValues: { ':project_members': project_members },
											ReturnValues: 'UPDATED_NEW',
										};
										updateDynamoRecord(updateProjectParams, callback, function(data) {
											auditLog(event.creater_email_id.trim(), 'Updated Member to the Project - ' + project.Items[0].project_name, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
												callback(null, { status: 'Success', Status_Message: ' Updated Member Successfully!!' });
											});
										});
									}
								});
							}
						}
					}
				});
			}
			else {
				callback(new Error('Project with ID: ' + event.project_id + " doesn't exist!!!"));
			}
		});
	}
	else {
		callback(new Error('Empty Field Occured Kindly add project ID and Member ID to update Project Member'));
	}
}

//This Function Will Get Executed When deleteProjectMember Fn is under execution and Removing the member
async function checkIfUserIsAssignedToAnyStep(project_id, user_id, callback, callbackFn) {
	let getAllSteps = {
		TableName: 'XcelAudit_Library_Steps',
		IndexName: 'project_id-index',
		KeyConditionExpression: '#project_id = :project_id',
		ExpressionAttributeNames: {
			'#project_id': 'project_id',
		},
		ExpressionAttributeValues: {
			':project_id': project_id,
		},
	};
	let data = await docClient.query(getAllSteps).promise();
	if (data.Count > 0) {
		for (let i = 0; i < data.Items.length; i++) {
			if (data.Items[i].assigned_to_user_ids != undefined && data.Items[i].assigned_to_user_ids.includes(user_id)) {
				callbackFn(true, data.Items[i]);
			}
		}
		while (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {
			let next_token = Buffer.from(JSON.stringify(data.LastEvaluatedKey)).toString('base64');
			getAllSteps.ExclusiveStartKey = JSON.parse(Buffer.from(next_token, 'base64').toString('ascii'));
			let data = await docClient.query(getAllSteps).promise();
			for (let i = 0; i < data.Count; i++) {
				if (data.Items[i].assigned_to_user_ids != undefined && data.Items[i].assigned_to_user_ids.includes(user_id)) {
					data.LastEvaluatedKey = undefined;
					callbackFn(true, data.Items[i]);
				}
			}
		}
		callbackFn(false, null);
	}
	else {
		callbackFn(false, null);
	}
}

function deleteProjectMember(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id },
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let checkIfUserExists = {
					TableName: 'XcelAudit_UserPortal_Users',
					KeyConditionExpression: '#user_id = :user_id',
					ExpressionAttributeNames: { '#user_id': 'user_id' },
					ExpressionAttributeValues: { ':user_id': event.user_id },
				};
				queryDynamo(checkIfUserExists, callback, function(user) {
					if (user.Count > 0) {
						let deleteMember = true;
						if (project.Items[0].EP_id == event.user_id) {
							deleteMember = false;
							callback(new Error('Cannot delete ' + user.Items[0].user_name + ' as he is EP For this Project'));
						}
						if (project.Items[0].TSR_id == event.user_id) {
							deleteMember = false;
							callback(new Error('Cannot delete ' + user.Items[0].user_name + ' as he is TSR For this Project'));
						}
						if (project.Items[0].QCP_id == event.user_id) {
							deleteMember = false;
							callback(new Error('Cannot delete ' + user.Items[0].user_name + ' as he is QCP For this Project'));
						}
						if (deleteMember) {
							checkIfUserIsAssignedToAnyStep(event.project_id, event.user_id, callback, function(is_assigned, step) {
								if (!is_assigned) {
									let OrginalProjectMembersList = project.Items[0].project_members;
									let updatedProjectMembersList = [];
									OrginalProjectMembersList.forEach((member) => {
										if (member.user_id != event.user_id) {
											updatedProjectMembersList.push(member);
										}
									});
									let updateProjectParams = {
										TableName: 'XcelAudit_Projects',
										Key: {
											project_id: event.project_id,
										},
										UpdateExpression: 'set project_members = :project_members',
										ExpressionAttributeValues: { ':project_members': updatedProjectMembersList },
										ReturnValues: 'UPDATED_NEW',
									};
									updateDynamoRecord(updateProjectParams, callback, function(data) {
										auditLog(event.creater_email_id.trim(), 'Deleted Member - ' + user.Items[0].user_name + 'From Project -' + project.Items[0].project_name, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
											callback(null, { status: 'Success', Status_Message: 'Deleted Member Successfully!!' });
										});
									});
								}
								else {
									callback(new Error('Cannot delete ' + user.Items[0].user_name + ' as he is assigned to step ' + step.step_name + ' under subStage ' + step.sub_stage_id + ' of Stage ' + step.stage_id));
								}
							});

						}
					}
					else {
						callback(new Error(' User with Id: ' + event.user_id + " desn't Exist!"));
					}
				});
			}
			else {
				callback(new Error('Project with Id: ' + event.project_id + " doesn't Exist!"));
			}
		});
	}
	else {
		callback(new Error('Empty Field Occured Cannot delete Member'));
	}
}

function assignOrUpdateStep(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id },
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				if (event.assign_to_user_ids.length > 0) {
					let runner = event.assign_to_user_ids.length;
					let assign_to_user_names = [];
					event.assign_to_user_ids.forEach((user_id) => {
						if (user_id.trim().length > 0) {
							let checkIfUserExists = {
								TableName: 'XcelAudit_UserPortal_Users',
								KeyConditionExpression: '#user_id = :user_id',
								FilterExpression: 'user_type = :user_type',
								ExpressionAttributeNames: { '#user_id': 'user_id' },
								ExpressionAttributeValues: { ':user_id': user_id, ':user_type': 'INTERNAL' },
							};
							queryDynamo(checkIfUserExists, callback, function(user) {
								if (user.Count > 0) {
									runner = runner - 1;
									assign_to_user_names.push(user.Items[0].user_name);
									if (runner == 0) {
										if (event.audit_step_ids.length > 0) {
											let steps_promises = event.audit_step_ids.map((step_id) => {
												let checkIfStepExists = {
													TableName: 'XcelAudit_Library_Steps',
													KeyConditionExpression: '#step_id = :step_id AND #sub_stage_id = :sub_stage_id',
													ExpressionAttributeNames: {
														'#step_id': 'step_id',
														'#sub_stage_id': 'sub_stage_id',
													},
													ExpressionAttributeValues: {
														':step_id': step_id,
														':sub_stage_id': event.sub_stage_id,
													},
												};
												let step = docClient.query(checkIfStepExists).promise();
												return step
													.then((steps) => {
														if (steps.Count > 0) {
															return steps.Items[0];
														}
														else {
															throw new Error('Step with ID ' + step_id + ' found');
														}
													})
													.then((singlestep) => {
														if (event.action == 'ASSIGN_STEP') {
															if (singlestep.assigned_to_user_ids == undefined || singlestep.assigned_to_user_ids.length == 0) {
																let insert_user_promises = event.assign_to_user_ids.map((user_id) => {
																	let newProjectParams = {
																		Item: {
																			...singlestep,
																			reviewer_user_id: event.reviewer_user_id,
																			'start_date': event.start_date,
																			'end_date': event.end_date,
																			'reviewer': event.reviewer,
																			'step_status': "PENDING"
																		},
																		TableName: 'XcelAudit_AssignedSteps',
																		ReturnValues: 'ALL_OLD',
																	};
																	newProjectParams.Item.user_id = user_id;
																	return docClient.put(newProjectParams).promise();
																});
																return Promise.all(insert_user_promises)
																	.then((data) => {
																		let updateStepParams = {
																			TableName: 'XcelAudit_Library_Steps',
																			Key: {
																				step_id: step_id,
																				sub_stage_id: event.sub_stage_id,
																			},
																			UpdateExpression: 'set assigned_to_user_names = :assigned_to_user_names,assigned_to_user_ids = :assigned_to_user_ids,start_date = :start_date,end_date = :end_date,reviewer = :reviewer,reviewer_user_id = :reviewer_user_id,step_status = :step_status',
																			ExpressionAttributeValues: {
																				':assigned_to_user_names': assign_to_user_names,
																				':assigned_to_user_ids': event.assign_to_user_ids,
																				':start_date': event.start_date,
																				':end_date': event.end_date,
																				':reviewer': event.reviewer,
																				':reviewer_user_id': event.reviewer_user_id,
																				':step_status': 'PENDING',
																			},
																			ReturnValues: 'UPDATED_NEW',
																		};
																		return docClient.update(updateStepParams).promise();
																	})
																	.catch((err) => {
																		throw new Error(err);
																	});
															}
															else {
																throw new Error('Step with ID: ' + singlestep.step_id + ' is already assigned');
															}
														}
														else if (event.action == 'UPDATE_STEP') {
															if (singlestep.assigned_to_user_ids != undefined || singlestep.assigned_to_user_ids.length != 0) {
																let updateStepParams = {
																	TableName: 'XcelAudit_Library_Steps',
																	Key: {
																		step_id: step_id,
																		sub_stage_id: event.sub_stage_id,
																	},
																	UpdateExpression: 'set assigned_to_user_names = :assigned_to_user_names,assigned_to_user_ids = :assigned_to_user_ids,start_date = :start_date,end_date = :end_date,reviewer = :reviewer,reviewer_user_id = :reviewer_user_id,uploaded_url = :uploaded_url,step_status = :step_status',
																	ExpressionAttributeValues: {
																		':assigned_to_user_names': assign_to_user_names,
																		':assigned_to_user_ids': event.assign_to_user_ids,
																		':start_date': event.start_date,
																		':end_date': event.end_date,
																		':reviewer': event.reviewer,
																		':reviewer_user_id': event.reviewer_user_id,
																		':uploaded_url': [],
																		':step_status': 'PENDING',
																	},
																	ReturnValues: 'UPDATED_NEW',
																};
																let update_promise = docClient.update(updateStepParams).promise();
																return update_promise
																	.then((response) => {
																		let old_users_ids = singlestep.assigned_to_user_ids;
																		let new_user_ids = event.assign_to_user_ids;
																		let users_to_delete = old_users_ids.filter((x) => !new_user_ids.includes(x));
																		let users_to_add = new_user_ids.filter((x) => !old_users_ids.includes(x));
																		let combined_array = users_to_delete.concat(users_to_add);
																		let to_update = old_users_ids.filter((x) => !combined_array.includes(x));
																		let users_Addition_priomises = users_to_add.map((user_id) => {
																			let newUserParams = {
																				Item: {
																					...singlestep,
																					reviewer: event.reviewer,
																					reviewer_user_id: event.reviewer_user_id,
																					start_date: event.start_date,
																					end_date: event.end_date
																				},
																				TableName: 'XcelAudit_AssignedSteps',
																				ReturnValues: 'ALL_OLD',
																			};
																			newUserParams.Item.user_id = user_id;
																			return docClient.put(newUserParams).promise();
																		});
																		let users_deletion_priomises = users_to_delete.map((user_id) => {
																			let deleteStepParams = {
																				TableName: 'XcelAudit_AssignedSteps',
																				Key: {
																					step_id: singlestep.step_id,
																					user_id: user_id,
																				},
																			};
																			return docClient.delete(deleteStepParams).promise();
																		});
																		let users_update_promises = to_update.map((user_id) => {
																			let updateStepParams = {
																				TableName: 'XcelAudit_AssignedSteps',
																				Key: {
																					step_id: singlestep.step_id,
																					user_id: user_id,
																				},
																				UpdateExpression: 'set assigned_to_user_names = :assigned_to_user_names,assigned_to_user_ids = :assigned_to_user_ids,start_date = :start_date,end_date = :end_date,reviewer = :reviewer,reviewer_user_id = :reviewer_user_id,step_status = :step_status',
																				ExpressionAttributeValues: {
																					':assigned_to_user_names': assign_to_user_names,
																					':assigned_to_user_ids': event.assign_to_user_ids,
																					':start_date': event.start_date,
																					':end_date': event.end_date,
																					':reviewer': event.reviewer,
																					':reviewer_user_id': event.reviewer_user_id,
																					':step_status': 'PENDING',
																				},
																				ReturnValues: 'UPDATED_NEW',
																			};
																			return docClient.update(updateStepParams).promise();
																		});
																		let allpromises = users_Addition_priomises.concat(users_deletion_priomises);
																		return Promise.all(allpromises, users_update_promises).then((response) => {
																			return 'Updated';
																		});
																	})
																	.catch((err) => {
																		callback(new Error(err));
																	});
															}
															else {
																throw new Error('Step with ID: ' + singlestep.step_id + ' is not assigned');
															}
														}
													})
													.catch((err) => {
														throw new Error(err);
													});
											});
											Promise.all(steps_promises)
												.then((steps) => {
													if (event.action == 'ASSIGN_STEP') {
														auditLog(event.creater_email_id.trim(), 'Assigned Step - ' + event.step_id + 'to :' + event.assign_to_user_ids, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
															callback(null, { status: 'Success', Status_Message: ' Assigned Step Successfully!!' });
														});
													}
													else if (event.action == 'UPDATE_STEP') {
														auditLog(event.creater_email_id.trim(), 'Updated Step - ' + event.step_id + 'to :' + event.assign_to_user_ids, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
															callback(null, { status: 'Success', Status_Message: ' Updated Step Successfully!!' });
														});
													}
												})
												.catch((err) => {
													console.log(err);
													callback(new Error(err));
												});
										}
										else {
											callback(new Error("Kindly, Send Step ID's To Assign OR Update Step"));
										}

									}
								}
								else {
									callback(new Error('User With ID: ' + user_id + ' not found'));
								}
							});
						}
					});
				}
				else {
					callback(new Error('Kindly Add User IDs to Assign Steps'));
				}
			}
			else {
				callback(new Error('Project with id: ' + event.project_id + ' not found'));
			}
		});
	}
	else {
		callback(new Error("Empty Fields Occured Cannot Update or Assigned Step"));
	}
}

function updateUploadedURL(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id },
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let checkIfUserExists = {
					TableName: 'XcelAudit_UserPortal_Users',
					KeyConditionExpression: '#user_id = :user_id',
					FilterExpression: 'user_type = :user_type',
					ExpressionAttributeNames: { '#user_id': 'user_id' },
					ExpressionAttributeValues: { ':user_id': event.creater_user_id, ':user_type': 'INTERNAL' },
				};
				queryDynamo(checkIfUserExists, callback, function(user) {
					if (user.Count > 0) {
						let checkIfStepExists = {
							TableName: 'XcelAudit_Library_Steps',
							KeyConditionExpression: '#step_id = :step_id AND #sub_stage_id = :sub_stage_id',
							FilterExpression: 'audit_library_id = :audit_library_id',
							ExpressionAttributeNames: {
								'#step_id': 'step_id',
								'#sub_stage_id': 'sub_stage_id'
							},
							ExpressionAttributeValues: {
								':step_id': event.step_id,
								':sub_stage_id': event.sub_stage_id,
								':audit_library_id': event.library_id
							}
						};
						queryDynamo(checkIfStepExists, callback, function(step) {
							if (step.Count > 0) {
								if (step.Items[0].assigned_to_user_ids != undefined && step.Items[0].assigned_to_user_ids.length != 0) {
									let updateProjectParams = {
										TableName: 'XcelAudit_Library_Steps',
										Key: {
											step_id: event.step_id,
											sub_stage_id: event.sub_stage_id,
										},
										UpdateExpression: 'set uploaded_url = :uploaded_url,file_object = :file_object,is_step_completed = :is_step_completed',
										ExpressionAttributeValues: { ':uploaded_url': event.uploaded_url, ':file_object': event.file_object, ':is_step_completed': true },
										ReturnValues: 'UPDATED_NEW',
									};
									updateDynamoRecord(updateProjectParams, callback, function(data) {
										let users_update_promises = step.Items[0].assigned_to_user_ids.map((user_id) => {
											let updateStepParams = {
												TableName: 'XcelAudit_AssignedSteps',
												Key: {
													step_id: event.step_id,
													user_id: user_id,
												},
												UpdateExpression: 'set uploaded_url = :uploaded_url,file_object = :file_object',
												ExpressionAttributeValues: {
													':uploaded_url': event.uploaded_url,
													':file_object': event.file_object,
												},
												ReturnValues: 'UPDATED_NEW',
											};
											return docClient.update(updateStepParams).promise();
										});
										return Promise.all(users_update_promises).then((response) => {
											auditLog(event.creater_email_id.trim(), 'Updated Uploaded URL for Step - ' + event.step_id + 'to :', event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
												callback(null, { status: 'Success', Status_Message: ' Updated Uploaded URL Successfully!!' });
											});
										});
									});
								}
								else {
									callback(new Error('Kindly, Assign Step before editing the assignment variables'));
								}
							}
							else {
								callback(new Error('Step Not Found'));
							}
						});
					}
					else {
						callback(new Error('Internal User with Id: ' + event.assigned_to_user_id + " desn't Exist!"));
					}
				});
			}
			else {
				callback(new Error('Project with Id: ' + event.project_id + " doesn't Exist!"));
			}
		});
	}
	else {
		callback(new Error('Empty Fields Occured Cannot create project'));
	}
}

function listAllURLBasesStepsOfProject(params, callback, callbackFn) {
	let steps = { Count: 0, Items: [] };

	function getURLSteps(params, callback, callbackFn) {
		queryDynamo(params, callback, function(data) {
			if (data.LastEvaluatedKey) {
				steps.Count += data.Count;
				steps.Items = steps.Items.concat(data.Items);
				params.ExclusiveStartKey = data.LastEvaluatedKey;
				getURLSteps(params, callback, callbackFn);
			}
			else {
				steps.Count += data.Count;
				steps.Items = steps.Items.concat(data.Items);
				callbackFn(steps);
			}
		});
	}
	getURLSteps(params, callback, callbackFn);
}

function listAllWorkDocsOfProject(event, context, callback) {
	if (event.user_id.trim().length > 0 && event.project_id.trim().length > 0) {
		let getUserDetails = {
			TableName: 'XcelAudit_UserPortal_Users',
			KeyConditionExpression: '#user_id = :user_id',
			ExpressionAttributeNames: { '#user_id': 'user_id' },
			FilterExpression: 'user_system_status = :user_system_status AND user_type = :user_type AND contains(projects, :project_id)',
			ExpressionAttributeValues: {
				':user_id': event.user_id,
				':user_system_status': 'ACTIVE',
				':user_type': 'INTERNAL',
				':project_id': event.project_id
			},
		};
		queryDynamo(getUserDetails, callback, function(Users) {
			if (Users.Count > 0) {
				let getProjectDetails = {
					TableName: 'XcelAudit_Projects',
					KeyConditionExpression: '#project_id = :project_id',
					FilterExpression: 'project_status <> :project_status',
					ExpressionAttributeNames: { '#project_id': 'project_id' },
					ExpressionAttributeValues: { ':project_id': event.project_id, ':project_status': 'ARCHIVED' },
				};
				queryDynamo(getProjectDetails, callback, function(project) {
					let getAllStepsForProjectsWithURLParams = {
						TableName: 'XcelAudit_Library_Steps',
						IndexName: 'project_id-index',
						KeyConditionExpression: '#project_id = :project_id',
						FilterExpression: "attribute_not_exists(uploaded_url) OR uploaded_url = :null",
						ExpressionAttributeNames: {
							'#project_id': 'project_id',
						},
						ExpressionAttributeValues: {
							':project_id': event.project_id,
							':null': null
						},
					};
					listAllURLBasesStepsOfProject(getAllStepsForProjectsWithURLParams, callback, function(steps) {
						if (steps.Count > 0) {
							let master_steps = steps.Items;
							let stages_array = [];
							if (master_steps.length > 0) {
								[...new Set(master_steps.map((obj) => obj.stage_name))].forEach((stage_name) => {
									let sub_stages = [];
									let filterSubStages = [...new Set(master_steps.filter((obj) => obj.stage_name == stage_name))];
									[...new Set(filterSubStages.map((obj) => obj.sub_stage_name))].forEach((sub_stage_name) => {
										let filteredSteps = [...new Set(master_steps.filter((obj) => obj.sub_stage_name == sub_stage_name))];
										let new_steps = [...new Set(filteredSteps.map((obj) => {
											return {
												step_name: obj.step_name,
												uploaded_url: obj.uploaded_url
											};
										}))];
										sub_stages.push({
											sub_stage_name: sub_stage_name,
											steps: new_steps,
										});
									});
									stages_array.push({
										stage_name: stage_name,
										sub_stages: sub_stages,
									});
								});
								project.stages = stages_array;
							}
							let data = {
								items: stages_array
							};
							callback(null, { status: 'SUCCESS', data });
						}
						else {
							callback(new Error("Currently There Are No Steps With Attchements"));
						}
					});
				});
			}
		});
	}
	else {
		callback(new Error("Kindly Enter Valid User ID And Project ID"));
	}
}

function addRemark(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id },
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let checkIfUserExists = {
					TableName: 'XcelAudit_UserPortal_Users',
					KeyConditionExpression: '#user_id = :user_id',
					FilterExpression: 'user_type = :user_type',
					ExpressionAttributeNames: { '#user_id': 'user_id' },
					ExpressionAttributeValues: { ':user_id': event.creater_user_id, ':user_type': 'INTERNAL' },
				};
				queryDynamo(checkIfUserExists, callback, function(user) {
					if (user.Count > 0) {
						let checkIfStepExists = {
							TableName: 'XcelAudit_Library_Steps',
							KeyConditionExpression: '#step_id = :step_id AND #sub_stage_id = :sub_stage_id',
							ExpressionAttributeNames: {
								'#step_id': 'step_id',
								'#sub_stage_id': 'sub_stage_id'
							},
							ExpressionAttributeValues: {
								':step_id': event.step_id,
								':sub_stage_id': event.sub_stage_id
							}
						};
						queryDynamo(checkIfStepExists, callback, function(step) {
							if (step.Count > 0) {
								if (step.Items[0].assigned_to_user_ids && step.Items[0].assigned_to_user_ids.length > 0) {
									let updateProjectParams = {
										TableName: 'XcelAudit_Library_Steps',
										Key: {
											step_id: event.step_id,
											sub_stage_id: event.sub_stage_id,
										},
										UpdateExpression: 'set step_remark = :step_remark',
										ExpressionAttributeValues: {
											':step_remark': event.step_remark
										},
										ReturnValues: 'UPDATED_NEW',
									};
									updateDynamoRecord(updateProjectParams, callback, function(data) {
										let users_update_promises = step.Items[0].assigned_to_user_ids.map((user_id) => {
											let updateStepParams = {
												TableName: 'XcelAudit_AssignedSteps',
												Key: {
													step_id: event.step_id,
													user_id: user_id,
												},
												UpdateExpression: 'set step_remark = :step_remark',
												ExpressionAttributeValues: {
													':step_remark': event.step_remark,
												},
												ReturnValues: 'UPDATED_NEW',
											};
											return docClient.update(updateStepParams).promise();
										});
										return Promise.all(users_update_promises).then((response) => {
											auditLog(event.creater_email_id.trim(), 'Added Remark for Step - ' + event.step_id + 'to :', event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
												callback(null, { status: 'Success', Status_Message: 'Added Remark Successfully!!' });
											});
										});
									});
								}
								else {
									callback(new Error('Kindly, Assign Step before editing the assignment variables'));
								}
							}
							else {
								callback(new Error('Step Not Found'));
							}
						});
					}
					else {
						callback(new Error('Internal User with Id: ' + event.assigned_to_user_id + " desn't Exist!"));
					}
				});
			}
			else {
				callback(new Error('Project with Id: ' + event.project_id + " doesn't Exist!"));
			}
		});
	}
	else {
		callback(new Error('Empty Fields Occured Cannot create project'));
	}
}

function signOffAuditStep(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id },
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let checkIfUserExists = {
					TableName: 'XcelAudit_UserPortal_Users',
					KeyConditionExpression: '#user_id = :user_id',
					FilterExpression: 'user_type = :user_type',
					ExpressionAttributeNames: { '#user_id': 'user_id' },
					ExpressionAttributeValues: { ':user_id': event.user_id, ':user_type': 'INTERNAL' },
				};
				queryDynamo(checkIfUserExists, callback, function(user) {
					if (user.Count > 0) {
						let checkIfStepExists = {
							TableName: 'XcelAudit_Library_Steps',
							KeyConditionExpression: '#step_id = :step_id AND sub_stage_id = :sub_stage_id',
							ExpressionAttributeNames: {
								'#step_id': 'step_id',
							},
							ExpressionAttributeValues: {
								':step_id': event.step_id,
								':sub_stage_id': event.sub_stage_id
							}
						};
						queryDynamo(checkIfStepExists, callback, function(step) {
							if (step.Count > 0) {
								if (step.Items[0].is_step_completed) {
									if (step.Items[0].assigned_to_user_ids != undefined) {
										let access = false;
										let status_update;
										if ((project.Items[0].EP_id != undefined && event.user_id == project.Items[0].EP_id) && step.Items[0].step_status == "PENDING_EP_REVIEW") {
											access = true;
											status_update = step.Items[0].qcp_review ? "PENDING_QCP_REVIEW" : "COMPLETED";
										}
										else if ((project.Items[0].QCP_id != undefined && event.user_id == project.Items[0].QCP_id) && step.Items[0].step_status == "PENDING_QCP_REVIEW") {
											access = true;
											status_update = "COMPLETED";
										}
										else if ((step.Items[0].assigned_to_user_ids.includes(event.user_id)) && step.Items[0].step_status == "PENDING") {
											access = true;
											status_update = "PENDING_REVIEW";
										}
										else if (step.Items[0].reviewer_user_id == event.user_id && step.Items[0].step_status == "PENDING_REVIEW") {
											access = true;
											if (step.Items[0].ep_review) {
												status_update = "PENDING_EP_REVIEW";
											}
											else if (step.Items[0].qcp_review) {
												status_update = "PENDING_QCP_REVIEW";
											}
											else {
												status_update = "COMPLETED";
											}
										}
										//FOR AUDIT TASKS WHEN ONE PERSON IS SIGNIN OFF KINDLY UPDATE IN ASSIGNED STEP TABLES AS SIGNED OFF SO THAT IT WONT GET LISTED IN AUDIT TASKS
										if (access) {
											let promise_array = [];
											if (status_update == "PENDING_REVIEW") {
												step.Items[0].assigned_to_user_ids.map((user_id, index) => {
													promise_array.push(
														new Promise((resolve, reject) => {
															let updateStepParams = {
																TableName: 'XcelAudit_AssignedSteps',
																Key: {
																	step_id: event.step_id,
																	user_id: user_id
																},
																UpdateExpression: 'set step_status = :step_status',
																ExpressionAttributeValues: {
																	':step_status': 'SIGNED_OFF',
																},
																ReturnValues: 'UPDATED_NEW',
															};
															updateDynamoRecord(updateStepParams, callback, function(data) {
																if (index == step.Items[0].assigned_to_user_ids.length - 1) {
																	//INSERT REVIEWER DATA INTO ASSIGNED STEPS AS PENDING_REVIEW
																	let newAssignStepParams = {
																		Item: {
																			...step.Items[0]
																		},
																		TableName: 'XcelAudit_AssignedSteps',
																		ReturnValues: 'ALL_OLD',
																	};
																	newAssignStepParams.Item.step_status = "PENDING_REVIEW";
																	newAssignStepParams.Item.user_id = step.Items[0].reviewer_user_id;
																	insertIntoDynamo(newAssignStepParams, callback, function(data) {
																		resolve(data);
																	});
																}
																else {
																	resolve(data);
																}
															});
														})
													);
												});
												promise_array.push(
													new Promise((resolve, reject) => {
														let updateStepParams = {
															TableName: 'XcelAudit_AssignedSteps',
															Key: {
																step_id: event.step_id,
																user_id: event.user_id
															},
															UpdateExpression: 'set step_status = :step_status',
															ExpressionAttributeValues: {
																':step_status': 'SIGNED_OFF',
															},
															ReturnValues: 'UPDATED_NEW',
														};
														updateDynamoRecord(updateStepParams, callback, function(data) {
															let getAssignedStepsParams = {
																TableName: 'XcelAudit_AssignedSteps',
																IndexName: 'sub_stage_id-step_id-index',
																KeyConditionExpression: 'sub_stage_id = :sub_stage_id AND step_id = :step_id',
																FilterExpression: "step_status = :step_status",
																ExpressionAttributeValues: {
																	':step_id': event.step_id,
																	':sub_stage_id': event.sub_stage_id,
																	':step_status': "PENDING"
																}
															};
															queryDynamo(getAssignedStepsParams, callback, function(step) {
																if (step.Count == 0) {
																	status_update = "PENDING_REVIEW";
																	resolve(step);
																}
																else {
																	resolve(step);
																}
															});
														});
													})
												);
											}
											else if (status_update == "PENDING_EP_REVIEW") {
												promise_array.push(
													new Promise((resolve, reject) => {
														let updateStepParams = {
															TableName: 'XcelAudit_AssignedSteps',
															Key: {
																step_id: event.step_id,
																user_id: event.user_id
															},
															UpdateExpression: 'set step_status = :step_status',
															ExpressionAttributeValues: {
																':step_status': 'SIGNED_OFF',
															},
															ReturnValues: 'UPDATED_NEW',
														};
														updateDynamoRecord(updateStepParams, callback, function(data) {
															//INSERT EP_REVIEW DATA INTO ASSIGNED STEPS WITH STATUS AS EP_REVIEW
															let newAssignStepParams = {
																Item: {
																	...step.Items[0]
																},
																TableName: 'XcelAudit_AssignedSteps',
																ReturnValues: 'ALL_OLD',
															};
															newAssignStepParams.Item.step_status = "PENDING_EP_REVIEW";
															newAssignStepParams.Item.user_id = project.Items[0].EP_id;
															insertIntoDynamo(newAssignStepParams, callback, function(data) {
																resolve(data);
															});
														});
													})
												);
											}
											else if (status_update == "PENDING_QCP_REVIEW") {
												promise_array.push(
													new Promise((resolve, reject) => {
														let updateStepParams = {
															TableName: 'XcelAudit_AssignedSteps',
															Key: {
																step_id: event.step_id,
																user_id: event.user_id
															},
															UpdateExpression: 'set step_status = :step_status',
															ExpressionAttributeValues: {
																':step_status': 'SIGNED_OFF',
															},
															ReturnValues: 'UPDATED_NEW',
														};
														updateDynamoRecord(updateStepParams, callback, function(data) {
															//INSERT QCP_REVIEW DATA INTO ASSIGNED STEPS WITH STATUS AS EP_REVIEW
															let newAssignStepParams = {
																Item: {
																	...step.Items[0]
																},
																TableName: 'XcelAudit_AssignedSteps',
																ReturnValues: 'ALL_OLD',
															};
															newAssignStepParams.Item.step_status = "PENDING_QCP_REVIEW";
															newAssignStepParams.Item.user_id = project.Items[0].QCP_id;
															if (project.Items[0].QCP_id.length > 0) {
																insertIntoDynamo(newAssignStepParams, callback, function(data) {
																	resolve(data);
																});
															}
															else {
																callback(new Error("Kindly Assign QCP TO project before signin off"));
															}
														});
													})
												);
											}
											else if (status_update == "COMPLETED") {
												promise_array.push(
													new Promise((resolve, reject) => {
														let updateStepParams = {
															TableName: 'XcelAudit_AssignedSteps',
															Key: {
																step_id: event.step_id,
																user_id: event.user_id
															},
															UpdateExpression: 'set step_status = :step_status',
															ExpressionAttributeValues: {
																':step_status': 'SIGNED_OFF',
															},
															ReturnValues: 'UPDATED_NEW',
														};
														updateDynamoRecord(updateStepParams, callback, function(data) {
															resolve(data);
														});
													})
												);
											}
											Promise.all(promise_array).then((Data) => {
												let updateStepParams = {
													TableName: 'XcelAudit_Library_Steps',
													Key: {
														step_id: event.step_id,
														sub_stage_id: event.sub_stage_id,
													},
													UpdateExpression: 'set step_status = :step_status',
													ExpressionAttributeValues: {
														':step_status': status_update,
													},
													ReturnValues: 'UPDATED_NEW',
												};
												console.log(updateStepParams);
												updateDynamoRecord(updateStepParams, callback, function(data) {
													let completed_weightage = project.Items[0].completed_weightage;
													let weightage_to_add = Number(step.Items[0].work_load_weightage) / Number(step.Items[0].weightage_breakup);
													completed_weightage += weightage_to_add;
													let percentage = ((completed_weightage / project.Items[0].library_weightage) * 100).toFixed(2) + '%';
													let updateProjectParams = {
														TableName: 'XcelAudit_Projects',
														Key: {
															project_id: event.project_id
														},
														UpdateExpression: 'set completed_weightage = :completed_weightage,project_progress = :project_progress',
														ExpressionAttributeValues: {
															':completed_weightage': completed_weightage,
															':project_progress': percentage
														},
														ReturnValues: 'UPDATED_NEW',
													};
													updateDynamoRecord(updateProjectParams, callback, function(data) {
														//auditLog(event.creater_email_id.trim(), 'Updated Step Status for Step - ' + event.step_id + 'to :' + event.step_status, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
														callback(null, { status: 'Success', Status_Message: ' Updated Step Status Successfully!!' });
														//});
													});
												});
											});
										}
										else {
											callback(new Error("You Cannot Update The Step Status"));
										}
									}
									else {
										callback(new Error('This Step is Not Assigned Yet'));
									}
								}
								else {
									callback(new Error("Kindly Complete The Step Before Signing Off"));
								}
							}
						});
					}
					else {
						callback(new Error('Internal User with Id: ' + event.creater_user_id + " desn't Exist!"));
					}
				});
			}
			else {
				callback(new Error('Project with Id: ' + event.project_id + " doesn't Exist!"));
			}
		});
	}
	else {
		callback(new Error('Empty Fields Occured Cannot create project'));
	}
}

function updateFormValues(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id },
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let stage_not_found = true;
				let sub_stage_not_found = true;
				let step_not_found = true;
				if (project.Items[0].selected_template_id == event.library_id) {
					let selected_template = project.Items[0].selected_template;
					for (let key in selected_template.audit_library_stages) {
						let singleStage = selected_template.audit_library_stages[key];
						if (singleStage.stage_id == event.stage_id) {
							stage_not_found = false;
							for (let element in singleStage.sub_stages) {
								let singleSubStage = singleStage.sub_stages[element];
								if (singleSubStage.sub_stage_id == event.sub_stage_id) {
									sub_stage_not_found = false;
									for (let parameter in singleSubStage.steps) {
										let singleStep = singleSubStage.steps[parameter];
										if (singleStep.step_id == event.step_id) {
											step_not_found = false;
											if (singleStep.assign_to_user_id.includes(event.user_id)) {
												for (let z = 0; z < event.form_array.length; z++) {
													singleStep[event.form_array[z].field_id].field_value = event.form_array[z].field_value;
												}
											}
											else {
												callback(new Error('You dont have permission to change the values of the form'));
											}
										}
									}
								}
							}
						}
					}
					if (!stage_not_found && !sub_stage_not_found && !step_not_found) {
						let updateProjectParams = {
							TableName: 'XcelAudit_Projects',
							Key: {
								project_id: event.project_id,
							},
							UpdateExpression: 'set selected_template = :selected_template',
							ExpressionAttributeValues: { ':selected_template': selected_template },
							ReturnValues: 'UPDATED_NEW',
						};
						updateDynamoRecord(updateProjectParams, callback, function(data) {
							auditLog(event.creater_email_id.trim(), 'Updated Form Value of step ' + event.step_id, event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
								callback(null, { status: 'Success', Status_Message: ' Updated Form Values Successfully!!' });
							});
						});
					}
					if (stage_not_found) {
						callback(new Error("Template Doesn't have Stage with ID: " + event.stage_id));
					}
					if (sub_stage_not_found) {
						callback(new Error("Template Doesn't have Sub-Stage with ID: " + event.sub_stage_id));
					}
					if (step_not_found) {
						callback(new Error("Template Doesn't have Step with ID: " + event.step_id));
					}
				}
			}
			else {
				callback(new Error('Project with ID: ' + event.project_id + 'not found'));
			}
		});
	}
	else {
		callback(new Error('Empty Fields occured cannot update form values'));
	}
}

function unlockProject(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id },
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let checkIfUserExists = {
					TableName: 'XcelAudit_UserPortal_Users',
					IndexName: 'user_email_id-index',
					KeyConditionExpression: '#user_email_id = :user_email_id',
					FilterExpression: 'user_system_status = :user_system_status AND user_status = :user_status',
					ExpressionAttributeNames: { '#user_email_id': 'user_email_id' },
					ExpressionAttributeValues: {
						':user_email_id': event.creater_email_id,
						':user_system_status': 'ACTIVE',
						':user_status': 'SUPER_ADMIN',
					},
				};
				queryDynamo(checkIfUserExists, callback, function(user) {
					if (user.Count > 0) {
						if (user.Items[0].user_id == project.Items[0].EP_id) {
							let updateProjectParams = {
								TableName: 'XcelAudit_Projects',
								Key: {
									project_id: event.project_id,
								},
								UpdateExpression: 'set project_status = :project_status, unlock_reason = :unlock_reason',
								ExpressionAttributeValues: { ':project_status': 'IN_PROGRESS', ':unlock_reason': event.reason },
								ReturnValues: 'UPDATED_NEW',
							};
							updateDynamoRecord(updateProjectParams, callback, function(data) {
								auditLog(event.creater_email_id.trim(), 'unlocked project' + project.Items[0].project_name + ' successfully with Note ' + event.reason + '!!', event.organisation_id, project.Items[0].client_id, event.project_id, function(value) {
									callback(null, { status: 'Success', Status_Message: ' Unlocked Project Successfully!!' });
								});
							});
						}
						else {
							callback(new Error('You Cannot unlock project as you are not EP of the project'));
						}
					}
					else {
						callback(new Error('Active Super Admin with Email: ' + event.creater_email_id + "Doesn't Exists"));
					}
				});
			}
			else {
				callback(new Error('Project with ID: ' + event.project_id + ' not found'));
			}
		});
	}
	else {
		callback(new Error('Empty Field Occured Cannot unlock project'));
	}
}

//BELOW CODE IS FOR AUDIT STEPS MODULE

function queryDynamoToGetAllStepsOfProjectForUser(user_id, project_id, ExclusiveStartKey, steps, callback) {
	let params = {
		TableName: 'XcelAudit_AssignedSteps',
		IndexName: 'user_id-project_id-index',
		KeyConditionExpression: 'user_id = :user_id AND project_id = :project_id',
		FilterExpression: 'step_status <> :step_status',
		ExpressionAttributeValues: {
			':user_id': user_id,
			':project_id': project_id,
			':step_status': "SIGNED_OFF"
		},
		ExclusiveStartKey: ExclusiveStartKey,
	};
	return new Promise(function(resolve, reject) {
		docClient.query(params, function(err, data) {
			if (err) {
				console.log(params, err);
				logErrorMsg(err, params, err.stack, callback, function(data) {
					reject(err);
				});
			}
			else {
				if (steps.Items != null) {
					steps.Items.push(...data.Items);
					steps.Count += data.Count;
				}
				else {
					steps.Items = data.Items;
					steps.Count += data.Count;
				}
				var response = {
					Count: steps.Count,
					Items: steps.Items,
					LastEvaluatedKey: data.LastEvaluatedKey,
				};
				if (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {
					resolve(queryDynamoToGetAllStepsOfProjectForUser(user_id, project_id, data.LastEvaluatedKey, response, callback));
				}
				else {
					resolve(response);
				}
			}
		});
	});
}

function listTasks(event, context, callback) {
	if (event.user_id.trim().length != 0) {
		let getUserDetails = {
			TableName: 'XcelAudit_UserPortal_Users',
			KeyConditionExpression: '#user_id = :user_id',
			ExpressionAttributeNames: { '#user_id': 'user_id' },
			FilterExpression: 'user_system_status = :user_system_status AND user_type = :user_type',
			ExpressionAttributeValues: {
				':user_id': event.user_id,
				':user_system_status': 'ACTIVE',
				':user_type': 'INTERNAL',
			},
		};
		queryDynamo(getUserDetails, callback, function(Users) {
			if (Users.Count > 0) {
				let user_projects = Users.Items[0].projects;
				if (user_projects.length > 0) {
					let projectsToGet = [];
					let projects_to_show = [];
					let total_project_count = user_projects.length;
					user_projects.forEach((project_id) => {
						let getProjectDetails = {
							TableName: 'XcelAudit_Projects',
							KeyConditionExpression: '#project_id = :project_id',
							FilterExpression: 'project_status <> :project_status',
							ExpressionAttributeNames: { '#project_id': 'project_id' },
							ExpressionAttributeValues: { ':project_id': project_id, ':project_status': 'ARCHIVED' },
						};
						queryDynamo(getProjectDetails, callback, function(project) {
							total_project_count = total_project_count - 1;
							if (project.Count > 0) {
								projectsToGet.push(project.Items[0]);
							}
							if (total_project_count == 0) {
								let project_promises = projectsToGet.map((project) => {
									let steps = queryDynamoToGetAllStepsOfProjectForUser(event.user_id, project.project_id, null, { Items: null, Count: 0 }, callback);
									return steps
										.then((steps) => {
											if (steps.Count > 0) {
												let stages_array = [];
												[...new Set(steps.Items.map((obj) => obj.stage_id))].forEach((stage_id) => {
													let sub_stages = [];
													let filterSubStages = [...new Set(steps.Items.filter((obj) => obj.stage_id == stage_id))];
													[...new Set(filterSubStages.map((obj) => obj.sub_stage_id))].forEach((sub_stage_id) => {
														let filteredSteps = [...new Set(steps.Items.filter((obj) => obj.sub_stage_id == sub_stage_id))];
														let new_steps = [...new Set(filteredSteps.map((obj) => obj.step_id))];
														sub_stages.push({
															sub_stage_id: sub_stage_id,
															steps: new_steps,
														});
													});
													stages_array.push({
														stage_id: stage_id,
														sub_stages: sub_stages,
													});
												});
												project.stages = stages_array;
												projects_to_show.push(project);
											}
										})
										.catch((err) => {
											throw new Error(err);
										});
								});
								Promise.all(project_promises)
									.then((data) => {
										if (projects_to_show.length > 0) {
											callback(null, projects_to_show);
										}
										else {
											callback(new Error('Currently There Are No Tasks Pending On You'));
										}
									})
									.catch((err) => {
										callback(new Error(err));
									});
							}
						});
					});
				}
				else {
					callback(new Error('You Dont Have Any Tasks Pending On You!!'));
				}
			}
			else {
				callback(new Error('User With ID: ' + event.user_id + ' not found'));
			}
		});
	}
}

function listStagesAndSubstageDetailsForTasks(event, context, callback) {
	if (event.stage_ids.length > 0) {
		let stage_promises = event.stage_ids.map((stage_id) => {
			let getProjectDetails = {
				TableName: 'XcelAudit_Stages_And_Substages',
				KeyConditionExpression: '#stage_id = :stage_id',
				ExpressionAttributeNames: { '#stage_id': 'stage_id' },
				ExpressionAttributeValues: { ':stage_id': stage_id }
			};
			let stage_details = docClient.query(getProjectDetails).promise();
			return stage_details
				.then((stagedata) => {
					if (stagedata.Count > 0) {
						return stagedata.Items[0];
					}
					else {
						callback(new Error('Cannot Find Stage With ID: ' + stage_id));
					}
				})
				.catch((err) => {
					callback(new Error(err));
				});
		});
		Promise.all(stage_promises)
			.then((data) => {
				callback(null, data);
			})
			.catch((err) => callback(new Error(err)));
	}
}

function listStepsForTasks(event, context, callback) {
	if (event.sub_stage_id.trim().length > 0 && event.step_ids.length > 0) {
		let steps_promises = event.step_ids.map((step_id) => {
			let getProjectDetails = {
				TableName: 'XcelAudit_Library_Steps',
				KeyConditionExpression: 'step_id = :step_id AND sub_stage_id = :sub_stage_id',
				ExpressionAttributeValues: { ':step_id': step_id, ':sub_stage_id': event.sub_stage_id },
			};
			let step_details = docClient.query(getProjectDetails).promise();
			return step_details
				.then((step_data) => {
					if (step_data.Count > 0) {
						return step_data.Items[0];
					}
					else {
						callback(new Error('Cannot Find Step With ID: ' + step_id));
					}
				})
				.catch((err) => {
					callback(new Error(err));
				});
		});
		Promise.all(steps_promises)
			.then((data) => {
				callback(null, data);
			})
			.catch((err) => callback(new Error(err)));
	}
}

//KINDLY CHECK AND DELETE BELOW THREE FUNCTIONS
function listProjectStages(event, context, callback) {
	if (event.project_id.trim().length != 0 && event.library_id.trim().length != 0) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id }
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let selectedLibrary = project.Items[0].selected_template;
				if (selectedLibrary.audit_library_id == event.library_id) {
					let response = {};
					response.items = selectedLibrary.audit_library_stages;
					callback(null, { status: 'SUCCESS', data: response });
				}
				else {
					callback(new Error('Template with ID: ' + event.library_id + ' not found!!!'));
				}
			}
			else {
				callback('Project With ID: ' + event.project_id + ' not Found!!');
			}
		});
	}
	else {
		callback(new Error('Empty Fields Occured kindly enter project_id and library_id to list stages'));
	}
}

function getAuditLibraryWithId(event, context, callback) {
	if (event.audit_library_id.trim().length != 0) {
		let checkIfAuditLibraryExists = {
			TableName: 'XcelAudit_AuditLibraries',
			KeyConditionExpression: '#audit_library_id = :audit_library_id',
			ExpressionAttributeNames: { '#audit_library_id': 'audit_library_id' },
			ExpressionAttributeValues: { ':audit_library_id': event.audit_library_id },
		};
		queryDynamo(checkIfAuditLibraryExists, callback, function(library) {
			if (library.Count > 0) {
				let response = {};
				response.items = library.Items;
				if (library.LastEvaluatedKey != undefined && library.LastEvaluatedKey != null) {
					response.next_token = Buffer.from(JSON.stringify(library.LastEvaluatedKey)).toString('base64');
				}
				callback(null, {
					status: 'SUCCESS',
					data: response,
				});
			}
			else {
				callback(new Error('Audit Library with id : ' + event.audit_library_id + ' not found!'));
			}
		});
	}
	else {
		callback(new Error('Kindly Enter Audit Library Id to list library'));
	}
}

function listAuditLibraries(event, context, callback) {
	let listAuditLibrariesParams = {
		TableName: 'XcelAudit_AuditLibraries',
		FilterExpression: 'audit_library_version > :audit_library_version',
		ExpressionAttributeValues: {
			':audit_library_version': 0
		},
		ScanIndexForward: false,
		Limit: 100,
	};
	if (event.next_token != null && event.next_token != undefined) {
		listAuditLibrariesParams.ExclusiveStartKey = JSON.parse(Buffer.from(event.next_token, 'base64').toString('ascii'));
	}
	scanDynamo(listAuditLibrariesParams, callback, function(data) {
		if (data.Count > 0) {
			let response = {};
			let libraries = data.Items;
			let librariesToShow = [];
			for (let key = 0; key < libraries.length; key++) {
				let library_not_present = true;
				if (librariesToShow.length != 0) {
					librariesToShow.forEach((library) => {
						if (library.audit_library_name == libraries[key].audit_library_name) {
							library_not_present = false;
						}
					});
				}
				if (library_not_present) {
					let elementToInsert = libraries[key];
					for (let item = 0; item < libraries.length; item++) {
						if (libraries[item].audit_library_name.trim() == libraries[key].audit_library_name.trim()) {
							if (libraries[item].audit_library_version > elementToInsert.audit_library_version) {
								elementToInsert = libraries[item];
							}
						}
					}
					if (elementToInsert.audit_library_status != "DRAFT") {
						librariesToShow.push(elementToInsert);
					}
				}
			}
			response.items = librariesToShow;
			if (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {
				response.next_token = Buffer.from(JSON.stringify(data.LastEvaluatedKey)).toString('base64');
			}
			callback(null, {
				status: 'SUCCESS',
				data: response,
			});
		}
		else {
			callback(new Error('No Audit Libraries Found'));
		}
	});
}

function submitAuditStepValues(event, context, callback) {
	if (event.type == "FORM") {
		submitAuditStepFormValues(event, context, callback);
	}
	else if (event.type == "CHECKLIST") {
		submitAuditStepCheckListValues(event, context, callback);
	}
}

function invokeSQS(userS3Creds, callbackFn) {
	let sqs_params = {
		MessageBody: JSON.stringify(userS3Creds),
		QueueUrl: constants.SQS_SHARE_QUEUE
	};
	sqs.sendMessage(sqs_params, function(err, data) {
		if (err) {
			console.log("Error", err);
		}
		else {
			console.log(sqs_params);
			callbackFn(data);
			console.log("Invoked SQS", userS3Creds);
		}
	});
}

function submitAuditStepFormValues(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let orginal_array = JSON.parse(JSON.stringify(event.fields_json));
		let lambda_event = {
			project_id: event.project_id
		};
		for (let i = 0; i < event.fields_json.length; i++) {
			if (i == 0) {
				lambda_event.project_id = event.project_id;
				lambda_event.audit_library_id = orginal_array[i].audit_library_id;
				lambda_event.stage_id = orginal_array[i].stage_id;
				lambda_event.sub_stage_id = orginal_array[i].sub_stage_id;
				lambda_event.step_id = orginal_array[i].step_id;
			}
			delete event.fields_json[i].audit_library_id;
			delete event.fields_json[i].stage_id;
			delete event.fields_json[i].sub_stage_id;
			delete event.fields_json[i].step_id;
			delete event.fields_json[i].field_applicable;
			delete event.fields_json[i].field_type;
			delete event.fields_json[i].field_options;
			delete event.fields_json[i].internal_field_type;
			delete event.fields_json[i].count;
			// delete event.fields_json[i].field_name;
			delete event.fields_json[i].field_configured;
			delete event.fields_json[i].form_id;
		}
		lambda_event.form_fields = event.fields_json;

		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': lambda_event.project_id }
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				let checkIfAuditLibraryExists = {
					TableName: 'XcelAudit_AuditLibraries',
					KeyConditionExpression: '#audit_library_id = :audit_library_id',
					ExpressionAttributeNames: { '#audit_library_id': 'audit_library_id' },
					FilterExpression: "project_id = :project_id",
					ExpressionAttributeValues: {
						':audit_library_id': lambda_event.audit_library_id,
						':project_id': lambda_event.project_id
					}
				};
				queryDynamo(checkIfAuditLibraryExists, callback, function(library) {
					if (library.Count > 0) {
						let checkIfStageExists = {
							TableName: 'XcelAudit_Stages_And_Substages',
							KeyConditionExpression: '#stage_id = :stage_id',
							ExpressionAttributeNames: { '#stage_id': 'stage_id' },
							ExpressionAttributeValues: { ':stage_id': lambda_event.stage_id }
						};
						queryDynamo(checkIfStageExists, callback, function(stage) {
							if (stage.Count > 0) {
								let checkIfSubStageExists = {
									TableName: 'XcelAudit_Stages_And_Substages',
									KeyConditionExpression: '#stage_id = :stage_id',
									ExpressionAttributeNames: { '#stage_id': 'stage_id' },
									ExpressionAttributeValues: { ':stage_id': lambda_event.sub_stage_id }
								};
								queryDynamo(checkIfSubStageExists, callback, function(substage) {
									if (substage.Count > 0) {
										let checkIfStepExists = {
											TableName: 'XcelAudit_Library_Steps',
											KeyConditionExpression: 'step_id = :step_id AND sub_stage_id = :sub_stage_id',
											ExpressionAttributeValues: { ':step_id': lambda_event.step_id, ':sub_stage_id': lambda_event.sub_stage_id }
										};
										queryDynamo(checkIfStepExists, callback, function(step) {
											if (step.Count > 0) {
												let promise_array = [];
												for (let i = 0; i < lambda_event.form_fields.length; i++) {
													let orginal_form_field_obj = JSON.parse(JSON.stringify(lambda_event.form_fields[i]));
													delete orginal_form_field_obj.field_id;
													delete orginal_form_field_obj.field_value;
													delete orginal_form_field_obj.field_value1;
													delete orginal_form_field_obj.field_value2;
													delete orginal_form_field_obj.field_value3;
													if (lambda_event.form_fields[i].field_value) {
														promise_array.push(
															new Promise((resolve, reject) => {
																let params = {
																	TableName: "XcelAudit_Steps_FormFields",
																	Key: {
																		"audit_library_id": lambda_event.audit_library_id,
																		"step_id__field_id": lambda_event.step_id + '__' + lambda_event.form_fields[i].field_id
																	},
																	ConditionExpression: "field_id = :field_id",
																	UpdateExpression: "set #field_value = :field_value",
																	ExpressionAttributeNames: {
																		"#field_value": "field_value"
																	},
																	ExpressionAttributeValues: {
																		":field_value": lambda_event.form_fields[i].field_value,
																		':field_id': lambda_event.form_fields[i].field_id
																	},
																	ReturnValues: "UPDATED_NEW"
																};
																if (Object.keys(orginal_form_field_obj).length) {
																	for (const property in orginal_form_field_obj) {
																		if (property != "step_id__field_id") {
																			params.UpdateExpression += `,#${property} = :${property}`;
																			params.ExpressionAttributeNames[`#${property}`] = property;
																			params.ExpressionAttributeValues[`:${property}`] = orginal_form_field_obj[property];
																		}
																	}
																}
																docClient.update(params, function(err, data) {
																	if (err) {
																		console.log(params, err);
																		reject(err);
																	}
																	else {
																		invokeSQS({
																			field_id: lambda_event.form_fields[i].field_id,
																			field_name: lambda_event.form_fields[i].field_name,
																			stage_name: stage.Items[0].stage_name,
																			old_step_id: step.Items[0].old_step_id,
																			old_sub_stage_id: step.Items[0].old_sub_stage_id,
																			sub_stage_name: substage.Items[0].stage_name,
																			step_name: step.Items[0].step_name,
																			field_value: lambda_event.form_fields[i].field_value,
																			step_id: lambda_event.step_id,
																			sub_stage_id: lambda_event.sub_stage_id,
																			stage_id: lambda_event.stage_id,
																			audit_library_id: lambda_event.audit_library_id,
																			project_id: lambda_event.project_id
																		}, function(data) {
																			resolve(data);
																		});
																		// resolve(data);
																	}
																});
															})
														);
													}
													else if (lambda_event.form_fields[i].field_value1) {
														promise_array.push(
															new Promise((resolve, reject) => {
																let params = {
																	TableName: "XcelAudit_Steps_FormFields",
																	Key: {
																		"audit_library_id": lambda_event.audit_library_id,
																		"step_id__field_id": lambda_event.step_id + '__' + lambda_event.form_fields[i].field_id
																	},
																	ConditionExpression: "#field_id = :field_id",
																	UpdateExpression: "set ",
																	ExpressionAttributeNames: {
																		"#field_id": "field_id"
																	},
																	ExpressionAttributeValues: {
																		':field_id': lambda_event.form_fields[i].field_id
																	},
																	ReturnValues: "UPDATED_NEW"
																};
																if (lambda_event.form_fields[i].field_value1) {
																	params.UpdateExpression += " field_value1 = :field_value1,";
																	params.ExpressionAttributeValues[':field_value1'] = lambda_event.form_fields[i].field_value1;
																}
																if (lambda_event.form_fields[i].field_value2) {
																	params.UpdateExpression += " field_value2 = :field_value2,";
																	params.ExpressionAttributeValues[':field_value2'] = lambda_event.form_fields[i].field_value2;
																}
																if (lambda_event.form_fields[i].field_value3) {
																	params.UpdateExpression += " field_value3 = :field_value3,";
																	params.ExpressionAttributeValues[':field_value3'] = lambda_event.form_fields[i].field_value3;
																}
																params.UpdateExpression = params.UpdateExpression.slice(0, -1);
																if (Object.keys(orginal_form_field_obj).length) {
																	for (const property in orginal_form_field_obj) {
																		if (property != "step_id__field_id") {
																			params.UpdateExpression += `,#${property} = :${property}`;
																			params.ExpressionAttributeNames[`#${property}`] = property;
																			params.ExpressionAttributeValues[`:${property}`] = orginal_form_field_obj[property];
																		}
																	}
																}
																docClient.update(params, function(err, data) {
																	if (err) {
																		console.log(params, err);
																		reject(err);
																	}
																	else {
																		invokeSQS({
																			field_id: lambda_event.form_fields[i].field_id,
																			field_name: lambda_event.form_fields[i].field_name,
																			stage_name: stage.Items[0].stage_name,
																			old_step_id: step.Items[0].old_step_id,
																			configured_step_id: step.Items[0].configured_step_id,
																			old_sub_stage_id: step.Items[0].old_sub_stage_id,
																			sub_stage_name: substage.Items[0].stage_name,
																			step_name: step.Items[0].step_name,
																			field_value: lambda_event.form_fields[i].field_value1,
																			step_id: lambda_event.step_id,
																			sub_stage_id: lambda_event.sub_stage_id,
																			stage_id: lambda_event.stage_id,
																			audit_library_id: lambda_event.audit_library_id,
																			project_id: lambda_event.project_id
																		}, function(data) {
																			resolve(data);
																		});
																	}
																});
															})
														);
													}
												}
												Promise.all(promise_array).then((data) => {
													if (step.Items[0].kob_step) {
														let updateStageParams = {
															TableName: "XcelAudit_Stages_And_Substages",
															Key: {
																"stage_id": lambda_event.stage_id
															},
															ExpressionAttributeNames: {
																"#current_step": "current_step"
															},
															UpdateExpression: "set #current_step = :current_step",
															ExpressionAttributeValues: {
																":current_step": stage.Items[0].current_step && stage.Items[0].current_step == "step4" ? "step4" : lambda_event.step_id
															},
															ReturnValues: "UPDATED_NEW"
														};
														updateDynamoRecord(updateStageParams, callback, function(data) {
															let updateParams = {
																TableName: "XcelAudit_Stages_And_Substages",
																Key: {
																	"stage_id": lambda_event.sub_stage_id
																},
																ExpressionAttributeNames: {
																	"#is_form_filled": "is_form_filled"
																},
																UpdateExpression: "set #is_form_filled = :is_form_filled",
																ExpressionAttributeValues: {
																	":is_form_filled": true
																},
																ReturnValues: "UPDATED_NEW"
															};
															updateDynamoRecord(updateParams, callback, function(data) {
																let updateStepParams = {
																	TableName: "XcelAudit_Library_Steps",
																	Key: {
																		"step_id": lambda_event.step_id,
																		"sub_stage_id": lambda_event.sub_stage_id
																	},
																	ExpressionAttributeNames: {
																		"#step_status": "step_status",
																		"#is_weightage_calculated": "is_weightage_calculated"
																	},
																	UpdateExpression: "set #step_status = :step_status,#is_weightage_calculated = :is_weightage_calculated",
																	ExpressionAttributeValues: {
																		":step_status": "COMPLETED",
																		":is_weightage_calculated": true
																	},
																	ReturnValues: "UPDATED_NEW"
																};
																updateDynamoRecord(updateStepParams, callback, function(data) {
																	if (!step.Items[0].is_weightage_calculated) {
																		let completed_weightage = project.Items[0].completed_weightage ? project.Items[0].completed_weightage : 0;
																		completed_weightage += step.Items[0].work_load_weightage;
																		let percentage = ((completed_weightage / project.Items[0].library_weightage) * 100).toFixed(2) + '%';
																		let updateProjectParams = {
																			TableName: 'XcelAudit_Projects',
																			Key: {
																				project_id: event.project_id
																			},
																			UpdateExpression: 'set completed_weightage = :completed_weightage,project_progress = :project_progress',
																			ExpressionAttributeValues: {
																				':completed_weightage': completed_weightage,
																				':project_progress': percentage
																			},
																			ReturnValues: 'UPDATED_NEW',
																		};
																		updateDynamoRecord(updateProjectParams, callback, function(data) {
																			callback(null, { status: 'Success', Status_Message: 'Saved Data Successfully!!' });
																		});
																	}
																	else {
																		callback(null, { status: 'Success', Status_Message: 'Saved Data Successfully!!' });
																	}
																});
															});
														});
													}
													else {
														let updateStepParams = {
															TableName: "XcelAudit_Library_Steps",
															Key: {
																"step_id": lambda_event.step_id,
																"sub_stage_id": lambda_event.sub_stage_id
															},
															ExpressionAttributeNames: {
																"#is_step_completed": "is_step_completed"
															},
															UpdateExpression: "set #is_step_completed = :is_step_completed",
															ExpressionAttributeValues: {
																":is_step_completed": true
															},
															ReturnValues: "UPDATED_NEW"
														};
														updateDynamoRecord(updateStepParams, callback, function(data) {
															callback(null, { status: 'Success', Status_Message: 'Saved Data Successfully!!' });
														});
													}
												}).catch(err => callback(new Error(err)));
											}
											else {
												callback(new Error("Step With ID: " + lambda_event.step_id + " Not Found"));
											}
										});
									}
									else {
										callback(new Error("SubStage With ID: " + lambda_event.sub_stage_id + "Not Found"));
									}
								});
							}
							else {
								callback(new Error("Stage With ID: " + lambda_event.stage_id + " Doesn't Exists"));
							}
						});
					}
					else {
						callback(new Error("Library With ID: " + lambda_event.audit_library_id + " Doesn't Exist"));
					}
				});
			}
			else {
				callback(new Error("Project With ID: " + lambda_event.project_id + " Not Found"));
			}
		});
	}
	else {
		callback(new Error('No Audit Libraries Found'));
	}
}

function submitAuditStepCheckListValues(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfProjectExists = {
			TableName: 'XcelAudit_Projects',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id }
		};
		queryDynamo(checkIfProjectExists, callback, function(project) {
			if (project.Count > 0) {
				event.audit_library_id = event.fields_json[0].audit_library_id;
				event.stage_id = event.fields_json[0].stage_id;
				event.sub_stage_id = event.fields_json[0].sub_stage_id;
				event.step_id = event.fields_json[0].step_id;
				let checkIfAuditLibraryExists = {
					TableName: 'XcelAudit_AuditLibraries',
					KeyConditionExpression: '#audit_library_id = :audit_library_id',
					ExpressionAttributeNames: { '#audit_library_id': 'audit_library_id' },
					FilterExpression: "project_id = :project_id",
					ExpressionAttributeValues: {
						':audit_library_id': event.audit_library_id,
						':project_id': event.project_id
					}
				};
				queryDynamo(checkIfAuditLibraryExists, callback, function(library) {
					if (library.Count > 0) {
						let checkIfStageExists = {
							TableName: 'XcelAudit_Stages_And_Substages',
							KeyConditionExpression: '#stage_id = :stage_id',
							ExpressionAttributeNames: { '#stage_id': 'stage_id' },
							ExpressionAttributeValues: { ':stage_id': event.stage_id }
						};
						queryDynamo(checkIfStageExists, callback, function(stage) {
							if (stage.Count > 0) {
								let checkIfSubStageExists = {
									TableName: 'XcelAudit_Stages_And_Substages',
									KeyConditionExpression: '#stage_id = :stage_id',
									ExpressionAttributeNames: { '#stage_id': 'stage_id' },
									ExpressionAttributeValues: { ':stage_id': event.sub_stage_id }
								};
								queryDynamo(checkIfSubStageExists, callback, function(substage) {
									if (substage.Count > 0) {
										let checkIfStepExists = {
											TableName: 'XcelAudit_Library_Steps',
											KeyConditionExpression: 'step_id = :step_id AND sub_stage_id = :sub_stage_id',
											ExpressionAttributeValues: { ':step_id': event.step_id, ':sub_stage_id': event.sub_stage_id }
										};
										queryDynamo(checkIfStepExists, callback, function(step) {
											let promise_array = [];
											for (let i = 0; i < event.fields_json.length; i++) {
												promise_array.push(
													new Promise((resolve, reject) => {
														let params = {
															TableName: "XcelAudit_Steps_FormFields",
															Key: {
																"audit_library_id": event.audit_library_id,
																"step_id__field_id": event.step_id + '__' + event.fields_json[i].field_id
															},
															ConditionExpression: "field_id = :field_id",
															UpdateExpression: "set",
															ExpressionAttributeNames: {},
															ExpressionAttributeValues: {
																':field_id': event.fields_json[i].field_id
															},
															ReturnValues: "UPDATED_NEW"
														};
														for (let property in event.fields_json[i]) {
															if (property == "field_value" || property == "comments" || property == "remarks" || property == "uploaded_url") {
																params.UpdateExpression += ` #${property} = :${property},`;
																params.ExpressionAttributeNames[`#${property}`] = property;
																params.ExpressionAttributeValues[`:${property}`] = event.fields_json[i][property];
															}
														}
														if (params.UpdateExpression != "set") {
															params.UpdateExpression = params.UpdateExpression.slice(0, -1);
															console.log(JSON.stringify(params));
															docClient.update(params, function(err, data) {
																if (err) {
																	reject(err);
																}
																else {
																	resolve(data);
																}
															});
														}
														else {
															resolve("Nothing To Update");
														}
													})
												);
											}
											Promise.all(promise_array).then(data => {
												let updateStepParams = {
													TableName: "XcelAudit_Library_Steps",
													Key: {
														"step_id": event.step_id,
														"sub_stage_id": event.sub_stage_id
													},
													ExpressionAttributeNames: {
														"#is_step_completed": "is_step_completed"
													},
													UpdateExpression: "set #is_step_completed = :is_step_completed",
													ExpressionAttributeValues: {
														":is_step_completed": true
													},
													ReturnValues: "UPDATED_NEW"
												};
												updateDynamoRecord(updateStepParams, callback, function(data) {
													callback(null, { status: 'Success', Status_Message: 'Submitted Checklist Successfully!!' });
												});
											});
										});
									}
									else {
										callback(new Error("Substage With ID: " + event.sub_stage_id + " not found"));
									}
								});
							}
							else {
								callback(new Error("Stage With ID: " + event.sub_stage_id + " Not Found"));
							}
						});
					}
					else {
						callback(new Error("Audit Library With ID: " + event.audit_libray_id + " Not Found"));
					}
				});
			}
			else {
				callback(new Error(" Project With ID: " + event.project_id + " Not Found"));
			}
		});
	}
	else {
		callback(new Error("Empty Fields Occured Cannot Submit Check List"));
	}
}

const dynamicSort = (property) => {
	var sortOrder = 1;
	if (property[0] === '-') {
		sortOrder = -1;
		property = property.substr(1);
	}
	return function(a, b) {
		if (sortOrder == -1) {
			return b[property].localeCompare(a[property]);
		}
		else {
			return a[property].localeCompare(b[property]);
		}
	};
};

function listFieldsOfFormOrChecklist(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfStepExists = {
			TableName: 'XcelAudit_Library_Steps',
			KeyConditionExpression: '#step_id = :step_id AND sub_stage_id = :sub_stage_id',
			ExpressionAttributeNames: { '#step_id': 'step_id' },
			ExpressionAttributeValues: {
				':step_id': event.step_id,
				':sub_stage_id': event.sub_stage_id
			}
		};
		queryDynamo(checkIfStepExists, callback, function(step) {
			if (step.Count > 0) {
				let getFieldsOfForm = {
					TableName: 'XcelAudit_Steps_FormFields',
					IndexName: 'audit_library_id-step_id-index',
					KeyConditionExpression: '#audit_library_id = :audit_library_id AND #step_id = :step_id',
					ExpressionAttributeNames: {
						'#audit_library_id': 'audit_library_id',
						'#step_id': 'step_id'
					},
					ExpressionAttributeValues: {
						':audit_library_id': step.Items[0].audit_library_id,
						':step_id': event.step_id
					},
				};
				queryDynamo(getFieldsOfForm, callback, function(fields) {
					if (fields.Count > 0) {
						if (step.Items[0].work_docs_type == "ChecklistBasedStep") {
							fields.Items.map(field => {
								field.remarks = '';
								field.commonvalue = '';
								return field;
							});
							fields.Items.sort((a, b) => a.count - b.count);
							let response = {
								number_of_items: step.Items[0].number_of_items,
								global_tooltips: step.Items[0].global_tooltips,
								is_global_applicability_configured: step.Items[0].is_global_applicability_configured,
								global_applicability_rules: step.Items[0].global_applicability_rules,
								notapplicablity: step.Items[0].notapplicablity,
								CheckListArray: fields.Items,
								applicable: step.Items[0].applicable,
								reason: step.Items[0].reason,
								general_paramerters: {
									project_name: step.Items[0].project_name,
									stage_name: step.Items[0].stage_name,
									sub_stage_name: step.Items[0].sub_stage_name,
									step_name: step.Items[0].step_name
								}
							};
							callback(null, {
								status: 'SUCCESS',
								data: response
							});
						}
						else if (step.Items[0].work_docs_type == "FormBasedStep") {
							let response = {};
							let promise_array = [];
							if (step.Items[0].form_name == "ApplicabilityChecklist.json") {
								promise_array.push(
									new Promise((resolve, reject) => {
										let getConstitutionData = {
											TableName: 'XcelAudit_Steps_FormFields',
											IndexName: 'audit_library_id-field_name-index',
											KeyConditionExpression: '#audit_library_id = :audit_library_id AND #field_name = :field_name',
											ExpressionAttributeNames: {
												'#audit_library_id': 'audit_library_id',
												'#field_name': 'field_name'
											},
											ExpressionAttributeValues: {
												':audit_library_id': step.Items[0].audit_library_id,
												':field_name': 'Constitution'
											},
										};
										queryDynamo(getConstitutionData, callback, function(data) {
											resolve({ Constitution: data.Items[0] });
										});
									})
								);
								promise_array.push(
									new Promise((resolve, reject) => {
										let getFinancialReportFramework = {
											TableName: 'XcelAudit_Steps_FormFields',
											IndexName: 'audit_library_id-field_name-index',
											KeyConditionExpression: '#audit_library_id = :audit_library_id AND #field_name = :field_name',
											ExpressionAttributeNames: {
												'#audit_library_id': 'audit_library_id',
												'#field_name': 'field_name'
											},
											ExpressionAttributeValues: {
												':audit_library_id': step.Items[0].audit_library_id,
												':field_name': 'Financial Reporting Framework'
											},
										};
										queryDynamo(getFinancialReportFramework, callback, function(data) {
											resolve({ 'Financial Reporting Framework': data.Items[0] });
										});
									})
								);
								promise_array.push(
									new Promise((resolve, reject) => {
										let getFinancialReportFramework = {
											TableName: 'XcelAudit_Steps_FormFields',
											IndexName: 'audit_library_id-field_name-index',
											KeyConditionExpression: '#audit_library_id = :audit_library_id AND #field_name = :field_name',
											ExpressionAttributeNames: {
												'#audit_library_id': 'audit_library_id',
												'#field_name': 'field_name'
											},
											ExpressionAttributeValues: {
												':audit_library_id': step.Items[0].audit_library_id,
												':field_name': '4.3 Revenue from Operations'
											},
										};
										queryDynamo(getFinancialReportFramework, callback, function(data) {
											resolve({ 'Revenue from Operations': data.Items[0] });
										});
									})
								);
							}
							//audit_library_id-field_name-index
							//sub_stage_id
							//if(step.Items[0].)
							// for (let i = 1; i < fields.Items.length; i++) {
							// 	if (fields.Items[i].internal_field_type != 'GRAND_CHILD' && fields.Items[i].count) {
							// 		fields.Items[i].count = fields.Items[i].count.toString();
							// 	}
							// }
							// fields.Items.sort(dynamicSort('count'));
							// for (let i = 0; i < fields.Items.length; i++) {
							// 	if (fields.Items[i].internal_field_type != 'GRAND_CHILD' && fields.Items[i].count) {
							// 		fields.Items[i].count = fields.Items[i].internal_field_type == 'PARENT' ? parseInt(fields.Items[i].count, 10) : parseFloat(fields.Items[i].count);
							// 	}
							// }
							Promise.all(promise_array).then((data) => {
								fields.Items.sort(function(a, b) {
									return a.count - b.count;
								});
								response.items = fields.Items;
								response.general_paramerters = {
									project_name: step.Items[0].project_name,
									stage_name: step.Items[0].stage_name,
									sub_stage_name: step.Items[0].sub_stage_name,
									step_name: step.Items[0].step_name
								};
								if (data.length > 0) {
									response.dependency_objects = data;
								}
								callback(null, {
									status: 'SUCCESS',
									data: response
								});
							});
						}
					}
					else {
						callback(new Error("This Form Doesn't Have Any Fields To List"));
					}
				});
			}
			else {
				callback(new Error("Step With ID: " + event.step_id + " Not Found"));
			}
		});
	}
	else {
		callback(new Error("Empty Fields Occured Cannot List Fields"));
	}
}

function listFieldsOfFormForWorkdocs(event, context, callback) {
	let checkEmptyFields = true;
	for (const field in event) {
		if (typeof event[field] == 'string') {
			if (event[field].trim().length == 0) {
				checkEmptyFields = false;
			}
		}
	}
	if (checkEmptyFields) {
		let checkIfStepExists = {
			TableName: 'XcelAudit_Library_Steps',
			IndexName: 'audit_library_id-step_id-index',
			KeyConditionExpression: '#audit_library_id = :audit_library_id AND step_id = :step_id',
			ExpressionAttributeNames: { '#audit_library_id': 'audit_library_id' },
			ExpressionAttributeValues: {
				':audit_library_id': event.audit_library_id,
				':step_id': event.step_id
			}
		};
		queryDynamo(checkIfStepExists, callback, function(step) {
			if (step.Count > 0) {
				let payload = {
					sub_stage_id: step.Items[0].sub_stage_id,
					step_id: event.step_id
				};
				listFieldsOfFormOrChecklist(payload, context, callback);
			}
			else {
				callback(new Error("Step With ID: " + event.step_id + " Under Library : " + event.audit_library_id + " Not Found"));
			}
		});
	}
	else {
		callback(new Error("Empty Fields Occured Cannot List Fields Of Form"));
	}
}

exports.handler = (event, context, callback) => {
	console.log('Event', event);
	switch (event.command) {
		case 'createProject':
			createProject(event, context, callback);
			break;
		case 'listArchivedProjects':
			listArchivedProjects(event, context, callback);
			break;
		case 'listProjectsWithIDs':
			listProjectsWithIDs(event, context, callback);
			break;
		case 'listProjectsForClient':
			listProjectsForClient(event, context, callback);
			break;
		case 'updateProjectStatus':
			updateProjectStatus(event, context, callback);
			break;
		case 'manageEP':
			manageEP(event, context, callback);
			break;
		case 'manageQCP':
			manageQCP(event, context, callback);
			break;
		case 'manageTSR':
			manageTSR(event, context, callback);
			break;
		case 'addProjectMember':
			addProjectMember(event, context, callback);
			break;
		case 'listProjectMembers':
			listProjectMembers(event, context, callback);
			break;
		case 'editProjectMember':
			editProjectMember(event, context, callback);
			break;
		case 'deleteProjectMember':
			deleteProjectMember(event, context, callback);
			break;
		case 'assignOrUpdateStep':
			assignOrUpdateStep(event, context, callback);
			break;
		case 'updateUploadedURL':
			updateUploadedURL(event, context, callback);
			break;
		case 'listAllWorkDocsOfProject':
			listAllWorkDocsOfProject(event, context, callback);
			break;
		case 'getAuditLibraryWithId':
			getAuditLibraryWithId(event, context, callback);
			break;
		case 'listAuditLibraries':
			listAuditLibraries(event, context, callback);
			break;
		case 'listProjectStages': // to be deleted
			listProjectStages(event, context, callback);
			break;
		case 'signOffAuditStep':
			signOffAuditStep(event, context, callback);
			break;
		case 'addRemark':
			addRemark(event, context, callback);
			break;
		case 'listTasks':
			listTasks(event, context, callback);
			break;
		case 'unlockProject':
			unlockProject(event, context, callback);
			break;
		case 'updateFormValues':
			updateFormValues(event, context, callback);
			break;
		case 'listStagesOfProjectLibrary':
			listStagesOfProjectLibrary(event, context, callback);
			break;
		case 'listSubstagesOfProjectLibrary':
			listSubstagesOfProjectLibrary(event, context, callback);
			break;
		case 'listStepsForSubstageOfProjectLibrary':
			listStepsForSubstageOfProjectLibrary(event, context, callback);
			break;
		case 'listStagesAndSubstageDetailsForTasks':
			listStagesAndSubstageDetailsForTasks(event, context, callback);
			break;
		case 'listStepsForTasks':
			listStepsForTasks(event, context, callback);
			break;
		case "submitAuditStepValues":
			submitAuditStepValues(event, context, callback);
			break;
		case "listFieldsOfFormOrChecklist":
			listFieldsOfFormOrChecklist(event, context, callback);
			break;
		case "listFieldsOfFormForWorkdocs":
			listFieldsOfFormForWorkdocs(event, context, callback);
			break;
		default:
			callback(new Error('Command not found'));
	}
};

//function stepAssigner(event, context, callback) {
//     let checkEmptyFields = true;
//     for (const field in event) {
//         if (typeof(event[field]) == 'string') {
//             if (event[field].trim().length == 0) {
//                 checkEmptyFields = false;
//             }
//         }
//     }
//     if (checkEmptyFields) {
//         let checkIfProjectExists = {
//             TableName: "XcelAudit_Projects",
//             KeyConditionExpression: '#project_id = :project_id',
//             ExpressionAttributeNames: { '#project_id': "project_id" },
//             ExpressionAttributeValues: { ':project_id': event.project_id }
//         };
//         queryDynamo(checkIfProjectExists, callback, function(project) {
//             if (project.Count > 0) {
//                 if (event.assign_to_user_id.length > 0) {
//                     let runner = event.assign_to_user_id.length;
//                     let assign_to_user_names = [];
//                     event.assign_to_user_id.forEach(user_id => {
//                         if (user_id.trim().length > 0) {
//                             let checkIfUserExists = {
//                                 TableName: "XcelAudit_UserPortal_Users",
//                                 KeyConditionExpression: '#user_id = :user_id',
//                                 FilterExpression: "user_type = :user_type",
//                                 ExpressionAttributeNames: { '#user_id': "user_id" },
//                                 ExpressionAttributeValues: { ':user_id': user_id, ':user_type': 'INTERNAL' }
//                             };
//                             queryDynamo(checkIfUserExists, callback, function(user) {
//                                 if (user.Count > 0) {
//                                     runner = runner - 1;
//                                     assign_to_user_names.push(user.Items[0].user_name);
//                                     if (runner == 0) {
//                                         let stage_not_found = true;
//                                         let sub_stage_not_found = true;
//                                         let step_not_found = true;
//                                         if (project.Items[0].selected_template_id == event.library_id) {
//                                             let selected_template = project.Items[0].selected_template;
//                                             for (let key in selected_template.audit_library_stages) {
//                                                 let singleStage = selected_template.audit_library_stages[key];
//                                                 if (singleStage.stage_id == event.stage_id) {
//                                                     stage_not_found = false;
//                                                     for (let element in singleStage.sub_stages) {
//                                                         let singleSubStage = singleStage.sub_stages[element];
//                                                         if (singleSubStage.sub_stage_id == event.sub_stage_id) {
//                                                             sub_stage_not_found = false;
//                                                             for (let parameter in singleSubStage.steps) {
//                                                                 let singleStep = singleSubStage.steps[parameter];
//                                                                 if (singleStep.step_id == event.step_id) {
//                                                                     step_not_found = false;
//                                                                     if (singleStep.assigned_to_user_id == undefined || singleStep.assigned_to_user_id.length == 0) {
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].assigned_to_user_names = assign_to_user_names;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].assigned_to_user_id = event.assign_to_user_id;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].start_date = event.start_date;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].end_date = event.end_date;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].reviewer = event.reviewer;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].reviewer_user_id = event.reviewer_user_id;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].uploaded_url = "";
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].step_status = "PENDING_ACTION";
//                                                                         if (event.uploaded_url != undefined) {
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].uploaded_url == event.uploaded_url;
//                                                                         }
//                                                                     }
//                                                                     else {
//                                                                         callback(new Error("This Step is Already Assigned to " + singleStep.assigned_to));
//                                                                     }
//                                                                 }
//                                                             }
//                                                         }
//                                                     }
//                                                 }
//                                             }
//                                             if (!stage_not_found && !sub_stage_not_found && !step_not_found) {
//                                                 let updateProjectParams = {
//                                                     TableName: "XcelAudit_Projects",
//                                                     Key: {
//                                                         project_id: event.project_id
//                                                     },
//                                                     UpdateExpression: "set selected_template = :selected_template",
//                                                     ExpressionAttributeValues: { ":selected_template": selected_template },
//                                                     ReturnValues: "UPDATED_NEW"
//                                                 };
//                                                 updateDynamoRecord(updateProjectParams, callback, function(data) {
//                                                     auditLog(event.creater_email_id.trim(), "Assigned Step - " + event.step_id + "to :" + event.assigned_to_user_id, event.organisation_id, function(value) {
//                                                         callback(null, { "status": "Success", "Status_Message": " Assigned Step Successfully!!" });
//                                                     });
//                                                 });
//                                             }
//                                             if (stage_not_found) {
//                                                 callback(new Error("Template Doesn't have Stage with ID: " + event.stage_id));
//                                             }
//                                             if (sub_stage_not_found) {
//                                                 callback(new Error("Template Doesn't have Sub-Stage with ID: " + event.sub_stage_id));
//                                             }
//                                             if (step_not_found) {
//                                                 callback(new Error("Template Doesn't have Step with ID: " + event.step_id));
//                                             }
//                                         }
//                                         else {
//                                             callback(new Error("Project with ID : " + event.project_id + " doesn't contain template with ID: " + event.library_id));
//                                         }
//                                     }
//                                 }
//                                 else {
//                                     callback(new Error("Internal User with Id: " + event.assigned_to_user_id + " desn't Exist!"));
//                                 }
//                             });
//                         }
//                         else {
//                             callback(new Error("Found An Empty User ID! Cannot assign step"));
//                         }
//                     });
//                 }
//                 else {
//                     callback(new Error("Kindly,Add User ID's to assign steps"));
//                 }
//             }
//             else {
//                 callback(new Error("Project with Id: " + event.project_id + " doesn't Exist!"));
//             }
//         });
//     }
//     else {
//         callback(new Error("Empty Fields Occured Cannot create project"));
//     }
// }

// function assignOrUpdateStep(event, context, callback) {
//     let checkEmptyFields = true;
//     for (const field in event) {
//         if (typeof(event[field]) == 'string') {
//             if (event[field].trim().length == 0) {
//                 checkEmptyFields = false;
//             }
//         }
//     }
//     if (checkEmptyFields) {
//         let checkIfProjectExists = {
//             TableName: "XcelAudit_Projects",
//             KeyConditionExpression: '#project_id = :project_id',
//             ExpressionAttributeNames: { '#project_id': "project_id" },
//             ExpressionAttributeValues: { ':project_id': event.project_id }
//         };
//         queryDynamo(checkIfProjectExists, callback, function(project) {
//             if (project.Count > 0) {
//                 if (event.assign_to_user_ids.length > 0) {
//                     let runner = event.assign_to_user_ids.length;
//                     let assign_to_user_names = [];
//                     event.assign_to_user_ids.forEach(user_id => {
//                         if (user_id.trim().length > 0) {
//                             let checkIfUserExists = {
//                                 TableName: "XcelAudit_UserPortal_Users",
//                                 KeyConditionExpression: '#user_id = :user_id',
//                                 FilterExpression: "user_type = :user_type",
//                                 ExpressionAttributeNames: { '#user_id': "user_id" },
//                                 ExpressionAttributeValues: { ':user_id': user_id, ':user_type': 'INTERNAL' }
//                             };
//                             queryDynamo(checkIfUserExists, callback, function(user) {
//                                 if (user.Count > 0) {
//                                     runner = runner - 1;
//                                     assign_to_user_names.push(user.Items[0].user_name);
//                                     if (runner == 0) {
//                                         if (event.audit_step_ids.length > 0) {
//                                             let step_runner = event.audit_step_ids.length;
//                                             event.audit_step_ids.forEach(step_id => {
//                                                 let checkIfStepExists = {
//                                                     TableName: 'XcelAudit_Library_Steps',
//                                                     KeyConditionExpression: '#step_id = :step_id AND #sub_stage_id = :sub_stage_id',
//                                                     ExpressionAttributeNames: {
//                                                         '#step_id': 'step_id',
//                                                         '#sub_stage_id': 'sub_stage_id'
//                                                     },
//                                                     ExpressionAttributeValues: {
//                                                         ':step_id': step_id,
//                                                         ':sub_stage_id': event.sub_stage_id
//                                                     },
//                                                 };
//                                                 queryDynamo(checkIfStepExists, callback, function(step) {
//                                                     if (step.Count > 0) {
//                                                         if (event.action == "ASSIGN_STEP") {
//                                                             if (step.Items[0].assigned_to_user_ids == undefined || step.Items[0].assigned_to_user_ids.length == 0) {
//                                                                 let updateStepParams = {
//                                                                     TableName: "XcelAudit_Library_Steps",
//                                                                     Key: {
//                                                                         step_id: step_id,
//                                                                         sub_stage_id: event.sub_stage_id
//                                                                     },
//                                                                     UpdateExpression: "set assigned_to_user_names = :assigned_to_user_names,assigned_to_user_ids = :assigned_to_user_ids,start_date = :start_date,end_date = :end_date,reviewer = :reviewer,reviewer_user_id = :reviewer_user_id,uploaded_url = :uploaded_url,step_status = :step_status",
//                                                                     ExpressionAttributeValues: {
//                                                                         ":assigned_to_user_names": assign_to_user_names,
//                                                                         ":assigned_to_user_ids": event.assign_to_user_ids,
//                                                                         ":start_date": event.start_date,
//                                                                         ":end_date": event.end_date,
//                                                                         ":reviewer": event.reviewer,
//                                                                         ":reviewer_user_id": event.reviewer_user_id,
//                                                                         ":uploaded_url": "",
//                                                                         ":step_status": "PENDING_ACTION"
//                                                                     },
//                                                                     ReturnValues: "UPDATED_NEW"
//                                                                 };
//                                                                 updateDynamoRecord(updateStepParams, callback, function(data) {
//                                                                     let user_runner = event.assign_to_user_ids.length;
//                                                                     event.assign_to_user_ids.forEach(user_id => {
//                                                                         let newProjectParams = {
//                                                                             Item: step.Items[0],
//                                                                             TableName: "XcelAudit_AssignedSteps",
//                                                                             ConditionExpression: "attribute_not_exists(project_id)",
//                                                                             ReturnValues: "ALL_OLD"
//                                                                         };
//                                                                         newProjectParams.Item.user_id = user_id;
//                                                                         insertIntoDynamo(newProjectParams, callback, function(InsertedData) {
//                                                                             step_runner = step_runner - 1;
//                                                                             user_runner = user_runner - 1;
//                                                                             if (step_runner == 0 && user_runner == 0) {
//                                                                                 auditLog(event.creater_email_id.trim(), "Assigned Step - " + event.step_id + "to :" + event.assigned_to_user_id, event.organisation_id, function(value) {
//                                                                                     callback(null, { "status": "Success", "Status_Message": " Assigned Step Successfully!!" });
//                                                                                 });
//                                                                             }
//                                                                         });
//                                                                     });
//                                                                 });
//                                                             }
//                                                             else {
//                                                                 callback(new Error("This Step is Already Assigned to " + step.assigned_to_user_names));
//                                                             }
//                                                         }
//                                                         else if (event.action == "UPDATE_STEP") {
//                                                             if (step.Items[0].assigned_to_user_ids != undefined || step.Items[0].assigned_to_user_ids.length != 0) {
//                                                                 let updateStepParams = {
//                                                                     TableName: "XcelAudit_Library_Steps",
//                                                                     Key: {
//                                                                         step_id: step_id,
//                                                                         sub_stage_id: event.sub_stage_id
//                                                                     },
//                                                                     UpdateExpression: "set assigned_to_user_names = :assigned_to_user_names,assigned_to_user_ids = :assigned_to_user_ids,start_date = :start_date,end_date = :end_date,reviewer = :reviewer,reviewer_user_id = :reviewer_user_id,uploaded_url = :uploaded_url,step_status = :step_status",
//                                                                     ExpressionAttributeValues: {
//                                                                         ":assigned_to_user_names": assign_to_user_names,
//                                                                         ":assigned_to_user_ids": event.assign_to_user_ids,
//                                                                         ":start_date": event.start_date,
//                                                                         ":end_date": event.end_date,
//                                                                         ":reviewer": event.reviewer,
//                                                                         ":reviewer_user_id": event.reviewer_user_id,
//                                                                         ":uploaded_url": "",
//                                                                         ":step_status": "PENDING_ACTION"
//                                                                     },
//                                                                     ReturnValues: "UPDATED_NEW"
//                                                                 };
//                                                                 updateDynamoRecord(updateStepParams, callback, function(data) {
//                                                                     let old_users_ids = step.Items[0].assigned_to_user_ids;
//                                                                     let new_user_ids = event.assign_to_user_ids;
//                                                                     let users_to_delete = old_users_ids.filter((x) => !new_user_ids.includes(x));
//                                                                     let users_to_add = new_user_ids.filter((x) => !old_users_ids.includes(x));
//                                                                     let user_runner = event.assign_to_user_ids.length;
//                                                                     let users_Addition_priomises = users_to_add.map(user_id => {
//                                                                         return new Promise((resolve, reject) => {
//                                                                             let newProjectParams = {
//                                                                                 Item: step.Items[0],
//                                                                                 TableName: "XcelAudit_AssignedSteps",
//                                                                                 ReturnValues: "ALL_OLD"
//                                                                             };
//                                                                             newProjectParams.Item.user_id = user_id;
//                                                                             docClient.put(newProjectParams, function(err, data) {
//                                                                                 if (err) {
//                                                                                     return reject(err);
//                                                                                 }
//                                                                                 else {
//                                                                                     resolve(data);
//                                                                                 }
//                                                                             });
//                                                                         })
//                                                                     });
//                                                                     let users_deletion_priomises = users_to_delete.map(user_id => {
//                                                                         return new Promise((resolve, reject) => {
//                                                                             let deleteStepParams = {
//                                                                                 TableName: "XcelAudit_AssignedSteps",
//                                                                                 Key: {
//                                                                                     "step_id": step.Items[0].step_id,
//                                                                                     "user_id": user_id
//                                                                                 },
//                                                                             };
//                                                                             docClient.delete(deleteStepParams, function(err, data) {
//                                                                                 if (err) {
//                                                                                     return reject(err);
//                                                                                 }
//                                                                                 else {
//                                                                                     resolve(data);
//                                                                                 }
//                                                                             });
//                                                                         })
//                                                                     });
//                                                                     let allpromises = users_Addition_priomises.concat(users_deletion_priomises)
//                                                                     Promise.all(allpromises).then((response) => {
//                                                                         step_runner = step_runner - 1;
//                                                                         if (step_runner == 0) {
//                                                                             auditLog(event.creater_email_id.trim(), "Assigned Step - " + event.step_id + "to :" + event.assigned_to_user_id, event.organisation_id, function(value) {
//                                                                                 callback(null, { "status": "Success", "Status_Message": " Assigned Step Successfully!!" });
//                                                                             });
//                                                                         }
//                                                                     });
//                                                                 });
//                                                             }
//                                                             else {
//                                                                 callback(new Error("Assign It Before Updating"));
//                                                             }
//                                                         }
//                                                     }
//                                                     else {
//                                                         callback(new Error("Step With ID: " + step_id + " not found!!! hint:Bro Step ID and User ID Array is same"));
//                                                     }
//                                                 });
//                                             });
//                                         }
//                                     }
//                                 }
//                                 else {
//                                     callback(new Error("Internal User with Id: " + user_id + " desn't Exist!"));
//                                 }
//                             });
//                         }
//                         else {
//                             callback(new Error("Empty user ID found"));

//                         }
//                     });
//                 }
//                 else {
//                     callback(new Error("Found An Empty User ID! Cannot assign step"));
//                 }
//             }
//             else {
//                 callback(new Error("Project With ID: " + event.project_id + " not found"));
//             }
//         });
//     }
//     else {
//         callback(new Error("Empty Fields Occured Cannot Assign Step"));
//     }
// }

// function bulkStepAssigner(event, context, callback) {
//     let checkEmptyFields = true;
//     for (const field in event) {
//         if (typeof(event[field]) == 'string') {
//             if (event[field].trim().length == 0) {
//                 checkEmptyFields = false;
//             }
//         }
//     }
//     if (checkEmptyFields) {
//         let checkIfProjectExists = {
//             TableName: "XcelAudit_Projects",
//             KeyConditionExpression: '#project_id = :project_id',
//             ExpressionAttributeNames: { '#project_id': "project_id" },
//             ExpressionAttributeValues: { ':project_id': event.project_id }
//         };
//         queryDynamo(checkIfProjectExists, callback, function(project) {
//             if (project.Count > 0) {
//                 if (event.assign_to_user_id.length > 0) {
//                     let runner = event.assign_to_user_id.length;
//                     let assign_to_user_names = [];
//                     event.assign_to_user_id.forEach(user_id => {
//                         if (user_id.trim().length > 0) {
//                             let checkIfUserExists = {
//                                 TableName: "XcelAudit_UserPortal_Users",
//                                 KeyConditionExpression: '#user_id = :user_id',
//                                 FilterExpression: "user_type = :user_type",
//                                 ExpressionAttributeNames: { '#user_id': "user_id" },
//                                 ExpressionAttributeValues: { ':user_id': user_id, ':user_type': 'INTERNAL' }
//                             };
//                             queryDynamo(checkIfUserExists, callback, function(user) {
//                                 if (user.Count > 0) {
//                                     runner = runner - 1;
//                                     assign_to_user_names.push(user.Items[0].user_name);
//                                     if (runner == 0) {
//                                         let stage_not_found = true;
//                                         let sub_stage_not_found = true;
//                                         let step_not_found = true;
//                                         if (project.Items[0].selected_template_id == event.library_id) {
//                                             let selected_template = project.Items[0].selected_template;
//                                             for (let key in selected_template.audit_library_stages) {
//                                                 let singleStage = selected_template.audit_library_stages[key];
//                                                 if (singleStage.stage_id == event.stage_id) {
//                                                     stage_not_found = false;
//                                                     for (let element in singleStage.sub_stages) {
//                                                         let singleSubStage = singleStage.sub_stages[element];
//                                                         if (singleSubStage.sub_stage_id == event.sub_stage_id) {
//                                                             sub_stage_not_found = false;
//                                                             for (let parameter in singleSubStage.steps) {
//                                                                 let singleStep = singleSubStage.steps[parameter];
//                                                                 event.audit_steps.steps.forEach(step_id => {
//                                                                     if (singleStep.step_id == step_id) {
//                                                                         step_not_found = false;
//                                                                         if (singleStep.assigned_to_user_id == undefined || singleStep.assigned_to_user_id.length == 0) {
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].assigned_to_user_names = assign_to_user_names;
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].assigned_to_user_id = event.assign_to_user_id;
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].start_date = event.start_date;
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].end_date = event.end_date;
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].reviewer = event.reviewer;
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].reviewer_user_id = event.reviewer_user_id;
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].step_assignment_status = event.step_assignment_status;
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].uploaded_url = "";
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].step_status = "PENDING_ACTION";
//                                                                             if (event.uploaded_url != undefined) {
//                                                                                 selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].uploaded_url == event.uploaded_url;
//                                                                             }
//                                                                         }
//                                                                         else {
//                                                                             callback(new Error("This Step is Already Assigned to " + singleStep.assigned_to));
//                                                                         }
//                                                                     }
//                                                                 });
//                                                             }
//                                                         }
//                                                     }
//                                                 }
//                                             }
//                                             if (!stage_not_found && !sub_stage_not_found && !step_not_found) {
//                                                 let updateProjectParams = {
//                                                     TableName: "XcelAudit_Projects",
//                                                     Key: {
//                                                         project_id: event.project_id
//                                                     },
//                                                     UpdateExpression: "set selected_template = :selected_template",
//                                                     ExpressionAttributeValues: { ":selected_template": selected_template },
//                                                     ReturnValues: "UPDATED_NEW"
//                                                 };
//                                                 updateDynamoRecord(updateProjectParams, callback, function(data) {
//                                                     auditLog(event.creater_email_id.trim(), "Assigned Step - " + event.step_id + "to :" + event.assigned_to_user_id, event.organisation_id, function(value) {
//                                                         callback(null, { "status": "Success", "Status_Message": " Assigned Step Successfully!!" });
//                                                     });
//                                                 });
//                                             }
//                                             if (stage_not_found) {
//                                                 callback(new Error("Template Doesn't have Stage with ID: " + event.stage_id));
//                                             }
//                                             if (sub_stage_not_found) {
//                                                 callback(new Error("Template Doesn't have Sub-Stage with ID: " + event.sub_stage_id));
//                                             }
//                                             if (step_not_found) {
//                                                 callback(new Error("Template Doesn't have Step with ID: " + event.audit_steps));
//                                             }
//                                         }
//                                         else {
//                                             callback(new Error("Project with ID : " + event.project_id + " doesn't contain template with ID: " + event.library_id));
//                                         }
//                                     }
//                                 }
//                                 else {
//                                     callback(new Error("Internal User with Id: " + user_id + " desn't Exist!"));
//                                 }
//                             });
//                         }
//                     });
//                 }
//                 else {
//                     callback(new Error("Found An Empty User ID! Cannot assign step"));

//                 }
//             }
//             else {
//                 callback(new Error("Project with Id: " + event.project_id + " doesn't Exist!"));
//             }
//         });
//     }
//     else {
//         callback(new Error("Empty Fields Occured Cannot create project"));
//     }
// }

// function updateAssignedStep(event, context, callback) {
//     let checkEmptyFields = true;
//     for (const field in event) {
//         if (typeof(event[field]) == 'string') {
//             if (event[field].trim().length == 0) {
//                 checkEmptyFields = false;
//             }
//         }
//     }
//     if (checkEmptyFields) {
//         let checkIfProjectExists = {
//             TableName: "XcelAudit_Projects",
//             KeyConditionExpression: '#project_id = :project_id',
//             ExpressionAttributeNames: { '#project_id': "project_id" },
//             ExpressionAttributeValues: { ':project_id': event.project_id }
//         };
//         queryDynamo(checkIfProjectExists, callback, function(project) {
//             if (project.Count > 0) {
//                 if (event.assign_to_user_id.length > 0) {
//                     let runner = event.assign_to_user_id.length;
//                     let assign_to_user_names = [];
//                     event.assign_to_user_id.forEach(user_id => {
//                         if (user_id.trim().length > 0) {
//                             let checkIfUserExists = {
//                                 TableName: "XcelAudit_UserPortal_Users",
//                                 KeyConditionExpression: '#user_id = :user_id',
//                                 FilterExpression: "user_type = :user_type",
//                                 ExpressionAttributeNames: { '#user_id': "user_id" },
//                                 ExpressionAttributeValues: { ':user_id': user_id, ':user_type': 'INTERNAL' }
//                             };
//                             queryDynamo(checkIfUserExists, callback, function(user) {
//                                 if (user.Count > 0) {
//                                     runner = runner - 1;
//                                     assign_to_user_names.push(user.Items[0].user_name);
//                                     if (runner == 0) {
//                                         let stage_not_found = true;
//                                         let sub_stage_not_found = true;
//                                         let step_not_found = true;
//                                         if (project.Items[0].selected_template_id == event.library_id) {
//                                             let selected_template = project.Items[0].selected_template;
//                                             for (let key in selected_template.audit_library_stages) {
//                                                 let singleStage = selected_template.audit_library_stages[key];
//                                                 if (singleStage.stage_id == event.stage_id) {
//                                                     stage_not_found = false;
//                                                     for (let element in singleStage.sub_stages) {
//                                                         let singleSubStage = singleStage.sub_stages[element];
//                                                         if (singleSubStage.sub_stage_id == event.sub_stage_id) {
//                                                             sub_stage_not_found = false;
//                                                             for (let parameter in singleSubStage.steps) {
//                                                                 let singleStep = singleSubStage.steps[parameter];
//                                                                 if (singleStep.step_id == event.step_id) {
//                                                                     step_not_found = false;
//                                                                     if (singleStep.assigned_to_user_id != undefined || singleStep.assigned_to_user_id.length != 0) {
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].assigned_to_user_names = assign_to_user_names;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].assigned_to_user_id = event.assign_to_user_id;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].start_date = event.start_date;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].end_date = event.end_date;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].reviewer = event.reviewer;
//                                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].step_assignment_status = event.step_assignment_status;
//                                                                         if (event.uploaded_url != undefined) {
//                                                                             selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].uploaded_url == event.uploaded_url;
//                                                                         }
//                                                                     }
//                                                                     else {
//                                                                         callback(new Error("Kindly, Assign Step before editing the assignment variables"));
//                                                                     }
//                                                                 }
//                                                             }
//                                                         }
//                                                     }
//                                                 }
//                                             }
//                                             if (!stage_not_found && !sub_stage_not_found && !step_not_found) {
//                                                 let updateProjectParams = {
//                                                     TableName: "XcelAudit_Projects",
//                                                     Key: {
//                                                         project_id: event.project_id
//                                                     },
//                                                     UpdateExpression: "set selected_template = :selected_template",
//                                                     ExpressionAttributeValues: { ":selected_template": selected_template },
//                                                     ReturnValues: "UPDATED_NEW"
//                                                 };
//                                                 updateDynamoRecord(updateProjectParams, callback, function(data) {
//                                                     auditLog(event.creater_email_id.trim(), "Updated Step Assignment - " + event.step_id + "to :" + event.assigned_to_user_id, event.organisation_id, function(value) {
//                                                         callback(null, { "status": "Success", "Status_Message": " Updated Step Assignment Successfully!!" });
//                                                     });
//                                                 });
//                                             }
//                                             if (stage_not_found) {
//                                                 callback(new Error("Template Doesn't have Stage with ID: " + event.stage_id));
//                                             }
//                                             if (sub_stage_not_found) {
//                                                 callback(new Error("Template Doesn't have Sub-Stage with ID: " + event.sub_stage_id));
//                                             }
//                                             if (step_not_found) {
//                                                 callback(new Error("Template Doesn't have Step with ID: " + event.step_id));
//                                             }
//                                         }
//                                         else {
//                                             callback(new Error("Project with ID : " + event.project_id + " doesn't contain template with ID: " + event.library_id));
//                                         }
//                                     }
//                                 }
//                                 else {
//                                     callback(new Error("Internal User with Id: " + event.assigned_to_user_id + " desn't Exist!"));
//                                 }
//                             });
//                         }
//                         else {
//                             callback(new Error("Found An Empty User ID! Cannot assign step"));
//                         }
//                     });
//                 }
//                 else {
//                     callback(new Error("Kindly,Add User ID's to assign steps"));
//                 }
//             }
//             else {
//                 callback(new Error("Project with Id: " + event.project_id + " doesn't Exist!"));
//             }
//         });
//     }
//     else {
//         callback(new Error("Empty Fields Occured Cannot create project"));
//     }
// }

// function updateUploadedURL(event, context, callback) {
//     let checkEmptyFields = true;
//     for (const field in event) {
//         if (typeof(event[field]) == 'string') {
//             if (event[field].trim().length == 0) {
//                 checkEmptyFields = false;
//             }
//         }
//     }
//     if (checkEmptyFields) {
//         let checkIfProjectExists = {
//             TableName: "XcelAudit_Projects",
//             KeyConditionExpression: '#project_id = :project_id',
//             ExpressionAttributeNames: { '#project_id': "project_id" },
//             ExpressionAttributeValues: { ':project_id': event.project_id }
//         };
//         queryDynamo(checkIfProjectExists, callback, function(project) {
//             if (project.Count > 0) {
//                 let checkIfUserExists = {
//                     TableName: "XcelAudit_UserPortal_Users",
//                     KeyConditionExpression: '#user_id = :user_id',
//                     FilterExpression: "user_type = :user_type",
//                     ExpressionAttributeNames: { '#user_id': "user_id" },
//                     ExpressionAttributeValues: { ':user_id': event.creater_user_id, ':user_type': 'INTERNAL' }
//                 };
//                 queryDynamo(checkIfUserExists, callback, function(user) {
//                     if (user.Count > 0) {
//                         let stage_not_found = true;
//                         let sub_stage_not_found = true;
//                         let step_not_found = true;
//                         if (project.Items[0].selected_template_id == event.library_id) {
//                             let selected_template = project.Items[0].selected_template;
//                             for (let key in selected_template.audit_library_stages) {
//                                 let singleStage = selected_template.audit_library_stages[key];
//                                 if (singleStage.stage_id == event.stage_id) {
//                                     stage_not_found = false;
//                                     for (let element in singleStage.sub_stages) {
//                                         let singleSubStage = singleStage.sub_stages[element];
//                                         if (singleSubStage.sub_stage_id == event.sub_stage_id) {
//                                             sub_stage_not_found = false;
//                                             for (let parameter in singleSubStage.steps) {
//                                                 let singleStep = singleSubStage.steps[parameter];
//                                                 if (singleStep.step_id == event.step_id) {
//                                                     step_not_found = false;
//                                                     if (singleStep.assigned_to_user_id != undefined || singleStep.assigned_to_user_id.length != 0) {
//                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].uploaded_url = event.uploaded_url;
//                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].file_object = event.file_object;
//                                                     }
//                                                     else {
//                                                         callback(new Error("Kindly, Assign Step before editing the assignment variables"));
//                                                     }
//                                                 }
//                                             }
//                                         }
//                                     }
//                                 }
//                             }
//                             if (!stage_not_found && !sub_stage_not_found && !step_not_found) {
//                                 let updateProjectParams = {
//                                     TableName: "XcelAudit_Projects",
//                                     Key: {
//                                         project_id: event.project_id
//                                     },
//                                     UpdateExpression: "set selected_template = :selected_template",
//                                     ExpressionAttributeValues: { ":selected_template": selected_template },
//                                     ReturnValues: "UPDATED_NEW"
//                                 };
//                                 updateDynamoRecord(updateProjectParams, callback, function(data) {
//                                     auditLog(event.creater_email_id.trim(), "Updated Uploaded URL for Step - " + event.step_id + "to :", event.organisation_id, function(value) {
//                                         callback(null, { "status": "Success", "Status_Message": " Updated Uploaded URL Successfully!!" });
//                                     });
//                                 });
//                             }
//                             if (stage_not_found) {
//                                 callback(new Error("Template Doesn't have Stage with ID: " + event.stage_id));
//                             }
//                             if (sub_stage_not_found) {
//                                 callback(new Error("Template Doesn't have Sub-Stage with ID: " + event.sub_stage_id));
//                             }
//                             if (step_not_found) {
//                                 callback(new Error("Template Doesn't have Step with ID: " + event.step_id));
//                             }
//                         }
//                         else {
//                             callback(new Error("Project with ID : " + event.project_id + " doesn't contain template with ID: " + event.library_id));
//                         }
//                     }
//                     else {
//                         callback(new Error("Internal User with Id: " + event.assigned_to_user_id + " desn't Exist!"));
//                     }
//                 });
//             }
//             else {
//                 callback(new Error("Project with Id: " + event.project_id + " doesn't Exist!"));
//             }
//         });
//     }
//     else {
//         callback(new Error("Empty Fields Occured Cannot create project"));
//     }
// }

// function updateStepStatus(event, context, callback) {
//     let checkEmptyFields = true;
//     for (const field in event) {
//         if (typeof(event[field]) == 'string') {
//             if (event[field].trim().length == 0) {
//                 checkEmptyFields = false;
//             }
//         }
//     }
//     if (checkEmptyFields) {
//         let checkIfProjectExists = {
//             TableName: "XcelAudit_Projects",
//             KeyConditionExpression: '#project_id = :project_id',
//             ExpressionAttributeNames: { '#project_id': "project_id" },
//             ExpressionAttributeValues: { ':project_id': event.project_id }
//         };
//         queryDynamo(checkIfProjectExists, callback, function(project) {
//             if (project.Count > 0) {
//                 let checkIfUserExists = {
//                     TableName: "XcelAudit_UserPortal_Users",
//                     KeyConditionExpression: '#user_id = :user_id',
//                     FilterExpression: "user_type = :user_type",
//                     ExpressionAttributeNames: { '#user_id': "user_id" },
//                     ExpressionAttributeValues: { ':user_id': event.creater_user_id, ':user_type': 'INTERNAL' }
//                 };
//                 queryDynamo(checkIfUserExists, callback, function(user) {
//                     if (user.Count > 0) {
//                         let stage_not_found = true;
//                         let sub_stage_not_found = true;
//                         let step_not_found = true;
//                         if (project.Items[0].selected_template_id == event.library_id) {
//                             let selected_template = project.Items[0].selected_template;
//                             for (let key in selected_template.audit_library_stages) {
//                                 let singleStage = selected_template.audit_library_stages[key];
//                                 if (singleStage.stage_id == event.stage_id) {
//                                     stage_not_found = false;
//                                     for (let element in singleStage.sub_stages) {
//                                         let singleSubStage = singleStage.sub_stages[element];
//                                         if (singleSubStage.sub_stage_id == event.sub_stage_id) {
//                                             sub_stage_not_found = false;
//                                             for (let parameter in singleSubStage.steps) {
//                                                 let singleStep = singleSubStage.steps[parameter];
//                                                 if (singleStep.step_id == event.step_id) {
//                                                     step_not_found = false;
//                                                     if (singleStep.assigned_to_user_id != undefined || singleStep.assigned_to_user_id != "") {
//                                                         selected_template.audit_library_stages[key].sub_stages[element].steps[parameter].step_status = event.step_status;
//                                                     }
//                                                     else {
//                                                         callback(new Error("Kindly, Assign Step before editing the assignment variables"));
//                                                     }
//                                                 }
//                                             }
//                                         }
//                                     }
//                                 }
//                             }
//                             if (!stage_not_found && !sub_stage_not_found && !step_not_found) {
//                                 let updateProjectParams = {
//                                     TableName: "XcelAudit_Projects",
//                                     Key: {
//                                         project_id: event.project_id
//                                     },
//                                     UpdateExpression: "set selected_template = :selected_template",
//                                     ExpressionAttributeValues: { ":selected_template": selected_template },
//                                     ReturnValues: "UPDATED_NEW"
//                                 };
//                                 updateDynamoRecord(updateProjectParams, callback, function(data) {
//                                     auditLog(event.creater_email_id.trim(), "Updated Step Status for Step - " + event.step_id + "to :", event.organisation_id, function(value) {
//                                         callback(null, { "status": "Success", "Status_Message": " Updated Step Status Successfully!!" });
//                                     });
//                                 });
//                             }
//                             if (stage_not_found) {
//                                 callback(new Error("Template Doesn't have Stage with ID: " + event.stage_id));
//                             }
//                             if (sub_stage_not_found) {
//                                 callback(new Error("Template Doesn't have Sub-Stage with ID: " + event.sub_stage_id));
//                             }
//                             if (step_not_found) {
//                                 callback(new Error("Template Doesn't have Step with ID: " + event.step_id));
//                             }
//                         }
//                         else {
//                             callback(new Error("Project with ID : " + event.project_id + " doesn't contain template with ID: " + event.library_id));
//                         }
//                     }
//                     else {
//                         callback(new Error("Internal User with Id: " + event.assigned_to_user_id + " desn't Exist!"));
//                     }
//                 });
//             }
//             else {
//                 callback(new Error("Project with Id: " + event.project_id + " doesn't Exist!"));
//             }
//         });
//     }
//     else {
//         callback(new Error("Empty Fields Occured Cannot create project"));
//     }
// }

// function listTasks(event, context, callback) {
//     if (event.user_id.trim().length != 0) {
//         let getUserDetails = {
//             TableName: "XcelAudit_UserPortal_Users",
//             KeyConditionExpression: '#user_id = :user_id',
//             ExpressionAttributeNames: { '#user_id': "user_id" },
//             FilterExpression: "user_system_status = :user_system_status AND user_type = :user_type",
//             ExpressionAttributeValues: {
//                 ':user_id': event.user_id,
//                 ':user_system_status': "ACTIVE",
//                 ':user_type': "INTERNAL"
//             }
//         };
//         queryDynamo(getUserDetails, callback, function(Users) {
//             if (Users.Count > 0) {
//                 let user_projects = Users.Items[0].projects;
//                 if (user_projects.length > 0) {
//                     let projectstoShow = [];
//                     let total_project_count = user_projects.length;
//                     user_projects.forEach(project_id => {
//                         let getProjectDetails = {
//                             TableName: "XcelAudit_Projects",
//                             KeyConditionExpression: '#project_id = :project_id',
//                             FilterExpression: 'project_status <> :project_status',
//                             ExpressionAttributeNames: { '#project_id': "project_id" },
//                             ExpressionAttributeValues: { ':project_id': project_id, ':project_status': "ARCHIVED" }
//                         };
//                         queryDynamo(getProjectDetails, callback, function(project) {
//                             total_project_count = total_project_count - 1;
//                             if (project.Count > 0) {
//                                 for (let item in project.Items[0].selected_template.audit_library_stages) {
//                                     let singleStage = project.Items[0].selected_template.audit_library_stages[item];
//                                     for (let element in singleStage.sub_stages) {
//                                         let singleSubStage = singleStage.sub_stages[element];
//                                         for (let key in singleSubStage.steps) {
//                                             let singleStep = singleSubStage.steps[key];
//                                             if (singleStep.assigned_to_user_id != undefined && singleStep.step_status != 'COMPLETED') {
//                                                 if (singleStep.assigned_to_user_id.includes(event.user_id)) {

//                                                 }
//                                                 else {
//                                                     delete singleSubStage.steps[key];
//                                                 }
//                                             }
//                                             else {
//                                                 delete singleSubStage.steps[key];
//                                             }
//                                         }
//                                         if (Object.keys(singleSubStage.steps).length == 0) {
//                                             delete project.Items[0].selected_template.audit_library_stages[item].sub_stages[singleSubStage.sub_stage_name];
//                                         }
//                                     }
//                                     if (Object.keys(singleStage.sub_stages).length == 0) {
//                                         delete project.Items[0].selected_template.audit_library_stages[item];
//                                     }
//                                 }
//                                 if (Object.keys(project.Items[0].selected_template.audit_library_stages).length > 0) {
//                                     projectstoShow.push(project.Items[0]);
//                                 }
//                             }
//                             if (total_project_count == 0) {
//                                 if (projectstoShow.length > 0) {
//                                     let response = {};
//                                     response.items = projectstoShow;
//                                     callback(null, {
//                                         "status": "SUCCESS",
//                                         data: response
//                                     });
//                                 }
//                                 else {
//                                     callback(new Error("Currently there are no tasks pending on you"));
//                                 }
//                             }
//                         });
//                     });
//                 }
//                 else {
//                     callback(new Error("Currently there are no tasks pending on you"));
//                 }
//             }
//             else {
//                 callback(new Error("No ACTIVE INTERNAL User was found With ID: " + event.user_id));
//             }
//         });
//     }
//     else {
//         callback(new Error("Kindly Enter User ID to list Tasks"));
//     }
// }

// function listTasksProjects(event, context, callback) {
//     if (event.user_id.trim().length != 0) {
//         let getUserDetails = {
//             TableName: "XcelAudit_UserPortal_Users",
//             KeyConditionExpression: '#user_id = :user_id',
//             ExpressionAttributeNames: { '#user_id': "user_id" },
//             FilterExpression: "user_system_status = :user_system_status AND user_type = :user_type",
//             ExpressionAttributeValues: {
//                 ':user_id': event.user_id,
//                 ':user_system_status': "ACTIVE",
//                 ':user_type': "INTERNAL"
//             }
//         };
//         queryDynamo(getUserDetails, callback, function(Users) {
//             if (Users.Count > 0) {
//                 let user_projects = Users.Items[0].projects;
//                 if (user_projects.length > 0) {
//                     let projectstoShow = [];
//                     let project_ids = [];
//                     let total_project_count = user_projects.length;
//                     user_projects.forEach(project_id => {
//                         let getProjectDetails = {
//                             TableName: "XcelAudit_Projects",
//                             KeyConditionExpression: '#project_id = :project_id',
//                             FilterExpression: 'project_status <> :project_status',
//                             ExpressionAttributeNames: { '#project_id': "project_id" },
//                             ExpressionAttributeValues: { ':project_id': project_id, ':project_status': "ARCHIVED" }
//                         };
//                         queryDynamo(getProjectDetails, callback, function(project) {
//                             total_project_count = total_project_count - 1;
//                             /*If Project members has any pending item*/
//                             if (project.Count > 0) {
//                                 projectstoShow.push(project);
//                                 project_ids.push(project.Items[0].project_id)
//                             }
//                             if (total_project_count == 0) {
//                                 getAllStepsForProjects(project_ids, event.user_id, function(projects) {
//                                     if (projects.steps.Count > 0) {
//                                         projectstoShow.push(project.Items[0])
//                                     }
//                                 });
//                             }
//                         });
//                     });
//                 }
//                 else {
//                     callback(new Error("Currently there are no tasks pending on you"));
//                 }
//             }
//             else {
//                 callback(new Error("No ACTIVE INTERNAL User was found With ID: " + event.user_id));
//             }
//         });
//     }
//     else {
//         callback(new Error("Kindly Enter User ID to list Tasks"));
//     }
// }
