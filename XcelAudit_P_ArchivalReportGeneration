var AWS = require('aws-sdk');
AWS.config.update({ region: 'ap-south-1' });
var docClient = new AWS.DynamoDB.DocumentClient();
const s3 = new AWS.S3();
var lambda = new AWS.Lambda();
const puppeteer = require('puppeteer-core');
const chromium = require('chrome-aws-lambda');

function invoke_lambda(payload, function_name, callbackFunction) {
	var params = {
		FunctionName: function_name,
		InvocationType: 'RequestResponse',
		Payload: JSON.stringify(payload),
	};
	var response = lambda.invoke(params, function(err, data) {
		if (err) {
			console.log(err, 'inside invoke_lambda: could not invoke: error stack: ' + err.stack);
		}
		else {
			if (typeof callbackFunction == 'function') callbackFunction(data);
		}
	});
}

function logErrorMsg(errMsg, params, stack, callback, callbackFn) {
	var msg = 'Lambda function name :' + process.env.AWS_LAMBDA_FUNCTION_NAME + '\n\nError message : \n' + JSON.stringify(errMsg) + '\n\nParams : \n' + JSON.stringify(params) + '\n\nStack : \n' + JSON.stringify(stack) + '\n\n Cloudwatch stream :' + process.env.AWS_LAMBDA_LOG_STREAM_NAME;
	invoke_lambda({ message: msg }, 'XcelAudit_B_P_ErrorLogs', function(data) {
		callback(errMsg);
	});
}

function auditLog(logger, message, organisation_id, client_id, project_id, callbackFunction) {
	var params = {
		FunctionName: 'XcelAudit_P_Logs',
		InvocationType: 'RequestResponse',
		Payload: JSON.stringify({ logger: logger, message: message, organisation_id: organisation_id, client_id: client_id, project_id: project_id }),
	};
	var response = lambda.invoke(params, function(err, data) {
		if (err) {
			console.log(err, 'inside invoke_lambda: could not invoke: error stack: ' + err.stack);
		}
		else {
			if (typeof callbackFunction == 'function') callbackFunction(data);
		}
	});
}

function queryDynamo(params, callback, callbackFn) {
	docClient.query(params, function(err, data) {
		if (err) {
			console.log(params, err);
			logErrorMsg(err, params, err.stack, callback, function(data) {
				callback(err);
			});
		}
		else {
			if (typeof callbackFn === 'function') {
				callbackFn(data);
			}
		}
	});
}

function insertIntoDynamo(params, callback, callbackFn) {
	docClient.put(params, function(err, data) {
		if (err) {
			logErrorMsg(err, params, err.stack, callback, function(data) {
				callback(err);
			});
		}
		else {
			if (typeof callbackFn === 'function') {
				callbackFn(data);
			}
		}
	});
}

function updateDynamoRecord(params, callback, callbackFn) {
	docClient.update(params, function(err, data) {
		if (err) {
			logErrorMsg(err, params, err.stack, callback, function(data) {
				callback(err);
			});
		}
		else {
			if (typeof callbackFn === 'function') {
				callbackFn(data);
			}
		}
	});
}

function scanDynamo(params, callback, callbackFn) {
	docClient.scan(params, function(err, data) {
		if (err) {
			logErrorMsg(err, params, err.stack, callback, function(data) {
				callback(err);
			});
		}
		else {
			if (typeof callbackFn === 'function') {
				callbackFn(data);
			}
		}
	});
}

function getAllStepsOfProject(params, callback, callbackFn) {
	let steps = { Count: 0, Items: [] };

	function getSteps(params, callback, callbackFn) {
		queryDynamo(params, callback, function(data) {
			if (data.LastEvaluatedKey) {
				steps.Count += data.Count;
				steps.Items = steps.Items.concat(data.Items);
				params.ExclusiveStartKey = data.LastEvaluatedKey;
				getSteps(params, callback, callbackFn);
			}
			else {
				steps.Count += data.Count;
				steps.Items = steps.Items.concat(data.Items);
				callbackFn(steps);
			}
		});
	}
	getSteps(params, callback, callbackFn);
}

exports.handler = (event, context, callback) => {
	let getProjectDetails = {
		TableName: 'XcelAudit_Projects',
		KeyConditionExpression: '#project_id = :project_id',
		ExpressionAttributeNames: { '#project_id': 'project_id' },
		ExpressionAttributeValues: { ':project_id': event.project_id }
	};
	queryDynamo(getProjectDetails, callback, function(project) {
		let htmlFile =
			'<html>' +
			'<style>' +
			`.body {
            padding: 70px;
			font-family:Calibri;
        	}` +
			`.size {
            font-size: 15px;
			font-family:Calibri;
        	}` +
			'</style>' +
			'<body class="body"> ' +
			' <p> ' +
			'<h1> Project Summary:</h1> ' +
			'</p>' +
			'<br>' +
			'<div class="size">' +
			'<b>' +
			'Project Name :' +
			'</b>' +
			`${project.Items[0].project_name}` +
			'<br>' +
			'<b>' +
			'Client Name :' +
			'</b>' +
			`${project.Items[0].client_name}` +
			'<br>' +
			'<b>' +
			'Audit Type :' +
			'</b>' +
			`GST Audit` +
			'<br>' +
			'<b>' +
			'Business Address :' +
			'</b>' +
			`${project.Items[0].client_address}` +
			'<br>' +
			'<br>' +
			'<br>' +
			'<b>' +
			'Audit Start Date :' +
			'</b>' +
			`${project.Items[0].project_start_date}` +
			'<br>' +
			'<b>' +
			'Audit End Date (Archival):' +
			'</b>' +
			`${project.Items[0].target_closure_date}` +
			'<br>' +
			'<b>' +
			'Number of Audit Steps :' +
			'</b>' +
			`${10}` +
			'<br>' +
			'<b>' +
			'Non-applicable Steps :' +
			'</b>' +
			`${10}` +
			'<br>' +
			'<b>' +
			'Audit Steps Completed :' +
			'</b>' +
			`${10}` +
			'<br>' +
			'<b>' +
			'Audit Steps Not Completed :' +
			'</b>' +
			`${10}` +
			'<br>' +
			'<b>' +
			'Percentage Of Audit Completed :' +
			'</b>' +
			`${project.Items[0].project_progress}` +
			'<br>' +
			'<br>' +
			'<br>' +
			'<b>' +
			'Engagement Partner :' +
			'</b>' +
			`${project.Items[0].EP}` +
			'<br>' +
			'<b>' +
			'QC Partner :' +
			'</b>' +
			`${project.Items[0].QCP}` +
			'<br>' +
			'<b>' +
			'TSQ Partner :' +
			'</b>' +
			`${project.Items[0].TSR}` +
			'<br>' +
			'<b>' +
			'Audit Team Members :' +
			'</b>' +
			`${project.Items[0].project_members}` +
			'<br>' +
			'<br>' +
			'<p>' +
			'<h2> Audit activities :</h2> ' +
			'</p>' +
			'<br>';

		let getAllStepsOfProjectParams = {
			TableName: 'XcelAudit_Library_Steps',
			IndexName: 'project_id-index',
			KeyConditionExpression: '#project_id = :project_id',
			ExpressionAttributeNames: { '#project_id': 'project_id' },
			ExpressionAttributeValues: { ':project_id': event.project_id }
		};
		getAllStepsOfProject(getAllStepsOfProjectParams, callback, function(data) {
			let htmlContent = '';
			for (let i = 0; i < data.Items.length; i++) {
				htmlContent += `<b> Step Name : ${data.Items[i].step_name} </b> </br>
					Step Description : ${data.Items[i].step_description} </br>
					Step Type : ${data.Items[i].work_docs_type} </br>
					Step Status : ${data.Items[i].step_status} </br>
					Completed On : ${Date.now()} </br>
					Completed by: ${"Syed Zahidulla"} </br>
					Reviewed By : ${"Riyad Sir"}</br></br>`;
			}
			htmlContent += '</div></body></html > ';
			htmlFile += htmlContent;
			// GENERATING PDF WILL HAPPEN WHEN PROJECT STATUS IS UPDATED AS ARCHIVED
			let params = {
				organisation_id: project.Items[0].organisation_id,
				client_id: project.Items[0].client_id,
				project_id: event.project_id,
				project_name: project.Items[0].project_name
			};
			generatePDF(params, htmlFile, callback, function(Data) {
				callback(null, "Success");
			});
		});
	});
};

async function generatePDF(event, htmlFile, callback, callbackFn) {
	const browser = await chromium.puppeteer.launch({
		args: chromium.args,
		defaultViewport: chromium.defaultViewport,
		executablePath: await chromium.executablePath,
		headless: chromium.headless,
		ignoreHTTPSErrors: true,
	});
	const page = await browser.newPage();
	await page.setContent(htmlFile);

	const pdf = await page.pdf({ format: 'A4' });
	//path: 'invoice.pdf',
	await browser.close();
	const uploadParams = {
		Bucket: 'xcel-audit-documents',
		ACL: 'public-read',
		Body: pdf,
		ContentType: 'application/pdf',
		Key: event.organisation_id + '/' + event.client_id + '/' + event.project_id + '/pdf/' + event.project_name + '.pdf',
	};
	s3.upload(uploadParams, (err, data) => {
		if (err) console.error('upload error', err);
		else {
			if (typeof callbackFn === 'function') {
				callbackFn(data);
			}
		}
	});
}
