// Project Creation Trigger And Library Unpublishing
//NOTING TO REMOVE
// XcelAuditProjectsTrigger

var AWS = require('aws-sdk');
AWS.config.update({ region: 'ap-south-1' });
var docClient = new AWS.DynamoDB.DocumentClient();
var uuid = require('uuid');
var sqs = new AWS.SQS();

async function invokeSQS(body) {
	try {
		let sqs_params = {
			MessageBody: JSON.stringify(body),
			QueueUrl: "https://sqs.ap-south-1.amazonaws.com/157247043770/XcelAudit_FieldsCreator"
		};
		// console.log(body);
		await sqs.sendMessage(sqs_params).promise();
		return "Successfully Invoked";
	}
	catch (err) {
		console.log(body)
		console.log("INVOKING SQS ERROR", err);
	}
}

const queryDynamo = async (params) => {
	try {
		let data = await docClient.query(params).promise();
		return data;
	}
	catch (err) {
		console.log(params, err);
		throw new Error(err);
	}
};

const insertIntoDynamo = async (params) => {
	try {
		await docClient.put(params).promise();
		return 'Success';
	}
	catch (err) {
		console.log(params, err);
		throw new Error(err);
	}
};

const updateDynamoRecord = async (params) => {
	try {
		await docClient.update(params).promise();
		return 'Success';
	}
	catch (err) {
		console.log(params, err);
		throw new Error(err);
	}
};

const wait = (ms) => new Promise((res) => setTimeout(res, ms));

const batchInsertDynamo = async (params, retryCount = 0) => {
	try {
		let res = await docClient.batchWrite(params).promise();
		if (res.UnprocessedItems && res.UnprocessedItems.length > 0) {
			console.log(`${res.UnprocessedItems.length} unprocessed item(s) left, retrying...`);
			if (retryCount > 2) {
				throw new Error(res.UnprocessedItems);
			}
			await wait(2 ** retryCount * 10);
			return batchInsertDynamo(res.UnprocessedItems, retryCount + 1);
		}
		return 'Success';
	}
	catch (err) {
		console.log(params, err);
		throw new Error(err);
	}
};

const recreateSubStagesAndSteps = async (project_name, stage_name, old_library_id, old_stage_id, old_sub_stage_id, new_library_id, new_stage_id, new_substage_id, project_id, action) => {
	console.log(project_name, stage_name, old_library_id, old_stage_id, old_sub_stage_id, new_library_id, new_stage_id, new_substage_id, project_id, action);
	let checkIfSubStageExists = {
		TableName: 'XcelAudit_Stages_And_Substages',
		KeyConditionExpression: '#stage_id = :stage_id',
		FilterExpression: '#type = :type',
		ExpressionAttributeNames: { '#stage_id': 'stage_id', '#type': 'type' },
		ExpressionAttributeValues: { ':stage_id': old_sub_stage_id, ':type': 'SUB_STAGE' },
	};
	let sub_stage = await queryDynamo(checkIfSubStageExists);
	let newAuditLibrarySubStageParams = {
		Item: {
			stage_id: new_substage_id,
			stage_name: sub_stage.Items[0].stage_name,
			stage_description: sub_stage.Items[0].stage_description,
			creater_email_id: sub_stage.Items[0].creater_email_id,
			audit_library_id: new_library_id,
			parent_stage_id: new_stage_id,
			number_of_steps: sub_stage.Items[0].number_of_steps,
			audit_library_id__parent_stage_id: new_library_id + '__' + new_stage_id,
			stage_created_on: sub_stage.Items[0].stage_created_on,
			type: 'SUB_STAGE',
		},
		TableName: 'XcelAudit_Stages_And_Substages',
		ConditionExpression: 'attribute_not_exists(stage_id)',
		ReturnValues: 'ALL_OLD',
	};
	if (action == 'CREATING_PROJECT') {
		newAuditLibrarySubStageParams.Item.project_id = project_id;
	}
	let random_uuid = uuid.v4();
	let kob_sub_stages = [];
	if (sub_stage.Items[0].stage_name == "Basic Information") {
		kob_sub_stages.push(new_substage_id);
		random_uuid = "step1";
		newAuditLibrarySubStageParams.Item.child_step_id = random_uuid;
		newAuditLibrarySubStageParams.Item.is_form_filled = true;
		//KINDLY CHANGE THE ABOVE PARAMETER TO FALSE ONCE DONE WITH TESTING
	}
	else if (sub_stage.Items[0].stage_name == "Basic Financial Data") {
		kob_sub_stages.push(new_substage_id);
		random_uuid = "step2";
		newAuditLibrarySubStageParams.Item.child_step_id = random_uuid;
		newAuditLibrarySubStageParams.Item.is_form_filled = true;
		//KINDLY CHANGE THE ABOVE PARAMETER TO FALSE ONCE DONE WITH TESTING
	}
	else if (sub_stage.Items[0].stage_name == "Additional Data") {
		kob_sub_stages.push(new_substage_id);
		random_uuid = "step3";
		newAuditLibrarySubStageParams.Item.child_step_id = random_uuid;
		newAuditLibrarySubStageParams.Item.is_form_filled = true;
		//KINDLY CHANGE THE ABOVE PARAMETER TO FALSE ONCE DONE WITH TESTING
	}
	else if (sub_stage.Items[0].stage_name == "Applicability Checklist") {
		kob_sub_stages.push(new_substage_id);
		random_uuid = "step4";
		newAuditLibrarySubStageParams.Item.child_step_id = random_uuid;
		newAuditLibrarySubStageParams.Item.is_form_filled = true;
		//KINDLY CHANGE THE ABOVE PARAMETER TO FALSE ONCE DONE WITH TESTING
	}
	//KINDLY REMOVE BELOW IF CODE FROM LINE NUMBER 125 TO 127 AFTER TESTING
	if (kob_sub_stages.length > 0) {
		newAuditLibrarySubStageParams.Item.current_step = "step4";
	}
	console.log("newAuditLibrarySubStageParams", JSON.stringify(newAuditLibrarySubStageParams));
	await insertIntoDynamo(newAuditLibrarySubStageParams);
	let allSteps = [];
	let getAllSteps = {
		TableName: 'XcelAudit_Library_Steps',
		IndexName: 'sub_stage_id-index',
		KeyConditionExpression: '#sub_stage_id = :sub_stage_id',
		ExpressionAttributeNames: {
			'#sub_stage_id': 'sub_stage_id',
		},
		ExpressionAttributeValues: {
			':sub_stage_id': old_sub_stage_id,
		},
	};
	console.log("getAllSteps", getAllSteps);
	let data = await queryDynamo(getAllSteps);
	if (data.Count > 0) {
		allSteps = data.Items;
		let kob_steps = [...data.Items];
		let step_ids = [];
		while (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {
			let next_token = Buffer.from(JSON.stringify(data.LastEvaluatedKey)).toString('base64');
			getAllSteps.ExclusiveStartKey = JSON.parse(Buffer.from(next_token, 'base64').toString('ascii'))
			// let getAllSteps = {
			// 	TableName: 'XcelAudit_Stages_And_Substages',
			// 	IndexName: 'sub_stage_id-index',
			// 	KeyConditionExpression: '#sub_stage_id = :sub_stage_id',
			// 	ExpressionAttributeNames: {
			// 		'#sub_stage_id': 'sub_stage_id',
			// 	},
			// 	ExpressionAttributeValues: {
			// 		':sub_stage_id': old_sub_stage_id,
			// 	},
			// 	ExclusiveStartKey: JSON.parse(Buffer.from(next_token, 'base64').toString('ascii')),
			// };
			data = await queryDynamo(getAllSteps);
			for (let i = 0; i < data.Count; i++) {
				allSteps.push(data.Items[i]);
			}
		}
		let stepsToCreate = [];
		while (allSteps.length) {
			stepsToCreate.push(allSteps.splice(0, 25));
		}

		for (let i = 0; i < stepsToCreate.length; i++) {
			let batchWriteParams = {
				RequestItems: {
					XcelAudit_Library_Steps: []
				},
			};
			for (let j = 0; j < stepsToCreate[i].length; j++) {
				let singleStep = stepsToCreate[i][j];
				console.log("singleStep", singleStep);
				let Item = {};
				for (let key in singleStep) {
					if (key == 'audit_library_id') {
						Item[key] = new_library_id;
					}
					else if (key == 'stage_id') {
						Item[key] = new_stage_id;
					}
					else if (key == 'sub_stage_id') {
						Item[key] = new_substage_id;
					}
					else if (key == 'step_id') {
						if (kob_sub_stages.includes(new_substage_id)) {
							step_ids.push({
								random_uuid,
								old_id: singleStep[key]
							});
							Item[key] = random_uuid;
						}
						else {
							let new_id = uuid.v4();
							step_ids.push({
								new_id,
								old_id: singleStep[key]
							});
							//changed from Items[key] = new_id to singlesteo.step_id
							Item[key] = singleStep.step_id;
						}
					}
					else {
						Item[key] = singleStep[key];
					}
				}
				Item["old_template_id"] = old_library_id;
				Item["old_stage_id"] = old_stage_id;
				Item["old_sub_stage_id"] = old_sub_stage_id;
				Item["old_step_id"] = singleStep.step_id;
				Item["applicable"] = true;
				Item["step_added_at"] = new Date().getTime();
				console.log("ITEM", Item);
				// Weightage Breakage.
				// By Default 2 Because everystep with have two sign offs one is step assigned to and one more reviewer.

				let weightage_breakup = 2;

				if (singleStep.ep_review) {
					weightage_breakup++;
				}

				if (singleStep.qcp_review) {
					weightage_breakup++;
				}
				if (action == 'CREATING_PROJECT') {
					Item['project_id'] = project_id;
					Item['project_name'] = project_name;
					Item['sub_stage_name'] = sub_stage.Items[0].stage_name;
					Item['stage_name'] = stage_name;
					Item['step_status'] = "PENDING";
					Item["weightage_breakup"] = kob_sub_stages.includes(new_substage_id) ? 1 : weightage_breakup;
					Item["ep_review"] = kob_sub_stages.includes(new_substage_id) ? false : singleStep.ep_review;
					Item["qcp_review"] = kob_sub_stages.includes(new_substage_id) ? false : singleStep.qcp_review;
					Item["is_weightage_calculated"] = false;
					Item['Remarks'] = '';
					Item['is_step_completed'] = false;
				}
				//get All The Rules And Override Them Here.
				console.log("RULES");
				let getAllRulesOfTheOldStep = {
					TableName: 'XcelAudit_ConfiguredRules',
					IndexName: 'audit_library_id-step_id-index',
					KeyConditionExpression: '#audit_library_id = :audit_library_id AND step_id = :step_id',
					ExpressionAttributeNames: {
						'#audit_library_id': 'audit_library_id'
					},
					ExpressionAttributeValues: {
						':audit_library_id': old_library_id,
						':step_id': Item.old_step_id
					},
				};
				let rules = await queryDynamo(getAllRulesOfTheOldStep);
				let allRules = rules.Items;
				console.log("ALL RULES", getAllRulesOfTheOldStep, allRules);
				while (rules.LastEvaluatedKey != undefined && rules.LastEvaluatedKey != null) {
					let next_token = Buffer.from(JSON.stringify(rules.LastEvaluatedKey)).toString('base64');
					getAllRulesOfTheOldStep.ExclusiveStartKey = JSON.parse(Buffer.from(next_token, 'base64').toString('ascii'));
					rules = await queryDynamo(getAllRulesOfTheOldStep);
					allRules = allRules.concat(rules.Items);
				}
				let rulesToCreate = [];
				while (allRules.length) {
					rulesToCreate.push(allRules.splice(0, 25));
				}
				console.log(rulesToCreate.length);
				for (let l = 0; l < rulesToCreate.length; l++) {
					let batchRulesWriteParams = {
						RequestItems: {
							XcelAudit_ConfiguredRules: []
						},
					};
					for (let m = 0; m < rulesToCreate[l].length; m++) {
						let singleRule = rulesToCreate[l][m];
						let ruleItem = {};
						for (let key in singleRule) {
							ruleItem[key] = singleRule[key];
							if (key == 'audit_library_id') {
								ruleItem[key] = new_library_id;
							}
							else if (key == 'stage_id') {
								ruleItem[key] = new_stage_id;
							}
							else if (key == 'sub_stage_id') {
								ruleItem[key] = new_substage_id;
							}
							else if (key == 'step_id') {
								ruleItem[key] = Item.step_id;
							}
						}
						batchRulesWriteParams.RequestItems.XcelAudit_ConfiguredRules.push({
							PutRequest: {
								Item: ruleItem,
							},
						});
					}
					console.log(batchRulesWriteParams);
					await batchInsertDynamo(batchRulesWriteParams);
				}
				console.log("RULES INSERTION FINISHED");
				//await invokeSQS(Item);
				//CONSOLE.
				// let getAllRulesOfTheNewStep = {
				// 	TableName: 'XcelAudit_ConfiguredRules',
				// 	IndexName: 'audit_library_id-configured_step_id-index',
				// 	KeyConditionExpression: '#audit_library_id = :audit_library_id AND configured_step_id = :configured_step_id',
				// 	ExpressionAttributeNames: {
				// 		'#audit_library_id': 'audit_library_id'
				// 	},
				// 	ExpressionAttributeValues: {
				// 		':audit_library_id': new_library_id,
				// 		':configured_step_id': Item.old_step_id
				// 	},
				// };
				// rules = await queryDynamo(getAllRulesOfTheNewStep);
				// console.log(JSON.stringify(rules));
				// let allOldRules = rules.Items;
				// while (rules.LastEvaluatedKey != undefined && rules.LastEvaluatedKey != null) {
				// 	let next_token = Buffer.from(JSON.stringify(rules.LastEvaluatedKey)).toString('base64');
				// 	getAllRulesOfTheNewStep.ExclusiveStartKey = JSON.parse(Buffer.from(next_token, 'base64').toString('ascii'));
				// 	rules = await queryDynamo(getAllRulesOfTheNewStep);
				// 	allOldRules = allOldRules.concat(rules.Items);
				// }
				// console.log(JSON.stringify(allOldRules));
				// for (let z = 0; z < allOldRules.length; z++) {
				// 	let updateRuleParams = {
				// 		//ADD UP KEY RESOLVED SOLUTION
				// 		TableName: "XcelAudit_ConfiguredRules",
				// 		Key: {
				// 			"audit_library_id": new_library_id,
				// 			"rule_id": allOldRules[z].rule_id
				// 		},
				// 		UpdateExpression: "set #configured_step_id = :configured_step_id",
				// 		ExpressionAttributeNames: {
				// 			"#configured_step_id": "configured_step_id"
				// 		},
				// 		ExpressionAttributeValues: {
				// 			":configured_step_id": Item.step_id
				// 		},
				// 		ReturnValues: "UPDATED_NEW"
				// 	};
				// 	console.log(updateRuleParams);
				// 	await updateDynamoRecord(updateRuleParams);
				// }

				// CONFIGURED STEPS UPDATION FINISHED
				batchWriteParams.RequestItems.XcelAudit_Library_Steps.push({
					PutRequest: {
						Item: Item,
					},
				});
			}
			await batchInsertDynamo(batchWriteParams);
			console.log('Success');
		}
		//SubStage Name consider the substage name
		// if (sub_stage.Items[0].stage_name == "Knowledge Of Business SubStage") {
		// 	for (let i = 0; i < kob_steps.length; i++) {
		// 		let params = {
		// 			Bucket: 'xcel-audit-documents',
		// 			Key: 'xcel-audit-documents/Knowledge Of Business Stage/AdditionalData.json',
		// 		};
		// 		let s3Bucket = new AWS.S3();
		// 		let data = await s3Bucket.getObject(params).promise();
		// 		let form_array = JSON.parse(data.Body.toString('utf-8'));
		// 		let field_array = form_array[0].fields;
		// 		let fieldsToCreate = [];
		// 		for (let i = 0; i < field_array.length; i++) {
		// 			while (field_array.length) {
		// 				fieldsToCreate.push(field_array.splice(0, 25));
		// 			}
		// 		}
		// 		for (let j = 0; j < fieldsToCreate[j].length; j++) {
		// 			let singleField = fieldsToCreate[i][j];
		// 			let Item = {};
		// 			for (var key in singleField) {
		// 				Item[key] = singleField[key];
		// 			}
		// 			Item['audit_library_id'] = new_library_id;
		// 			Item['stage_id'] = new_stage_id;
		// 			Item['sub_stage_id'] = new_substage_id;
		// 			Item['step_id'] = uuid.v4();
		// 		}
		// 	}
		// }
		return 'Success';
	}
	else {
		return 'AbdSuccess';
	}
};

const recreateStages = async (project_name, old_library_id, stage_id, new_library_id, new_stage_id, project_id, action) => {
	let checkIfStageExists = {
		TableName: 'XcelAudit_Stages_And_Substages',
		KeyConditionExpression: '#stage_id = :stage_id',
		ExpressionAttributeNames: { '#stage_id': 'stage_id' },
		ExpressionAttributeValues: { ':stage_id': stage_id },
	};
	let stage = await queryDynamo(checkIfStageExists);
	let newAuditLibraryStageParams = {
		Item: {
			stage_id: new_stage_id,
			stage_name: stage.Items[0].stage_name,
			stage_description: stage.Items[0].stage_description,
			creater_email_id: stage.Items[0].creater_email_id,
			number_of_sub_stages: stage.Items[0].number_of_sub_stages,
			number_of_steps: stage.Items[0].number_of_steps,
			stage_created_on: stage.Items[0].stage_created_on,
			audit_library_id: new_library_id,
			type: 'STAGE',
		},
		TableName: 'XcelAudit_Stages_And_Substages',
		ConditionExpression: 'attribute_not_exists(stage_id)',
		ReturnValues: 'ALL_OLD',
	};
	if (action == 'CREATING_PROJECT') {
		newAuditLibraryStageParams.Item.project_id = project_id;
	}
	//KINDLY REMOVE BELOW IF CODE FROM LINE NUMBER 424 TO 426
	if (stage.Items[0].stage_name == "Knowledge Of Business Stage") {
		newAuditLibraryStageParams.Item.current_step = "step4";
	}
	await insertIntoDynamo(newAuditLibraryStageParams);
	let allSubstages = [];
	let getAllSubstages = {
		TableName: 'XcelAudit_Stages_And_Substages',
		IndexName: 'audit_library_id__parent_stage_id-type-index',
		KeyConditionExpression: '#audit_library_id__parent_stage_id = :audit_library_id__parent_stage_id AND #type = :type',
		ExpressionAttributeNames: {
			'#audit_library_id__parent_stage_id': 'audit_library_id__parent_stage_id',
			'#type': 'type',
		},
		ExpressionAttributeValues: {
			':audit_library_id__parent_stage_id': old_library_id + '__' + stage_id,
			':type': 'SUB_STAGE',
		},
	};
	let data = await queryDynamo(getAllSubstages);
	if (data.Count > 0) {
		allSubstages = data.Items;
		while (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {
			let next_token = Buffer.from(JSON.stringify(data.LastEvaluatedKey)).toString('base64');
			let getAllSubstages = {
				TableName: 'XcelAudit_Stages_And_Substages',
				IndexName: 'audit_library_id__parent_stage_id-type-index',
				KeyConditionExpression: '#audit_library_id__parent_stage_id = :audit_library_id__parent_stage_id AND #type = :type',
				ExpressionAttributeNames: {
					'#audit_library_id__parent_stage_id': 'audit_library_id__parent_stage_id',
					'#type': 'type',
				},
				ExpressionAttributeValues: {
					':audit_library_id__parent_stage_id': old_library_id + '__' + stage_id,
					':type': 'SUB_STAGE',
				},
				ExclusiveStartKey: JSON.parse(Buffer.from(next_token, 'base64').toString('ascii')),
			};
			data = await queryDynamo(getAllSubstages);
			for (let i = 0; i < data.Count; i++) {
				allSubstages.push(data.Items[i]);
			}
		}
		for (let i = 0; i < allSubstages.length; i++) {
			let new_substage_id;
			let check_substage_exists = true;
			while (check_substage_exists) {
				let new_id = uuid.v4();
				let checkIfSubStageExists = {
					TableName: 'XcelAudit_Stages_And_Substages',
					KeyConditionExpression: '#stage_id  = :stage_id',
					ExpressionAttributeNames: { '#stage_id': 'stage_id' },
					ExpressionAttributeValues: { ':stage_id': new_id },
				};
				let substage = await queryDynamo(checkIfSubStageExists);
				if (substage.Count == 0) {
					check_substage_exists = false;
					new_substage_id = new_id;
				}
			}
			await recreateSubStagesAndSteps(project_name, stage.Items[0].stage_name, old_library_id, stage_id, allSubstages[i].stage_id, new_library_id, new_stage_id, new_substage_id, project_id, action);
			console.log(project_name, stage.Items[0].stage_name, old_library_id, stage_id, allSubstages[i].stage_id, new_library_id, new_stage_id, new_substage_id, project_id, action);
		}
		return 'Success';
	}
	else {
		return 'Success';
	}
};

const recreateLibrary = async (project_name, new_library_id, old_library_id, project_id, action) => {
	let checkIfLibraryExists = {
		TableName: 'XcelAudit_AuditLibraries',
		KeyConditionExpression: '#audit_library_id = :audit_library_id',
		ExpressionAttributeNames: { '#audit_library_id': 'audit_library_id' },
		ExpressionAttributeValues: { ':audit_library_id': old_library_id },
	};
	let library = await queryDynamo(checkIfLibraryExists);
	if (library.Count > 0) {
		if (action == 'CREATING_PROJECT') {
			let newAuditLibraryParams = {
				Item: {
					audit_library_id: new_library_id,
					audit_library_name: library.Items[0].audit_library_name,
					audit_library_description: library.Items[0].audit_library_description,
					creater_email_id: library.Items[0].creater_email_id,
					audit_library_status: library.Items[0].audit_library_status,
					audit_library_version: 0,
					created_at: new Date().getTime(),
					number_of_library_stages: library.Items[0].number_of_library_stages,
					number_of_sub_stages: library.Items[0].number_of_sub_stages,
					number_of_steps: library.Items[0].number_of_steps,
					project_id: project_id,
					is_used: true,
					library_weightage: library.Items[0].library_weightage
				},
				TableName: 'XcelAudit_AuditLibraries',
				ConditionExpression: 'attribute_not_exists(audit_library_id)',
				ReturnValues: 'ALL_OLD',
			};
			await insertIntoDynamo(newAuditLibraryParams);
		}
		let allStages = [];
		let getAllStages = {
			TableName: 'XcelAudit_Stages_And_Substages',
			IndexName: 'audit_library_id-type-index',
			KeyConditionExpression: '#audit_library_id = :audit_library_id AND #type = :type',
			ExpressionAttributeNames: {
				'#audit_library_id': 'audit_library_id',
				'#type': 'type',
			},
			ExpressionAttributeValues: {
				':audit_library_id': old_library_id,
				':type': 'STAGE',
			},
		};
		let data = await queryDynamo(getAllStages);
		if (data.Count > 0) {
			allStages = data.Items;
			while (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {
				let next_token = Buffer.from(JSON.stringify(data.LastEvaluatedKey)).toString('base64');
				let getAllStages = {
					TableName: 'XcelAudit_Stages_And_Substages',
					IndexName: 'audit_library_id-type-index',
					KeyConditionExpression: '#audit_library_id = :audit_library_id AND #type = :type',
					ExpressionAttributeNames: {
						'#audit_library_id': 'audit_library_id',
						'#type': 'type',
					},
					ExpressionAttributeValues: {
						':audit_library_id': old_library_id,
						':type': 'STAGE',
					},
					ExclusiveStartKey: JSON.parse(Buffer.from(next_token, 'base64').toString('ascii')),
				};
				data = await queryDynamo(getAllStages);
				for (let i = 0; i < data.Count; i++) {
					allStages.push(data.Items[i]);
				}
			}
			for (let i = 0; i < allStages.length; i++) {
				let new_stage_id;
				let check_stage_exists = true;
				while (check_stage_exists) {
					let new_id = uuid.v4();
					let checkIfStageExists = {
						TableName: 'XcelAudit_Stages_And_Substages',
						KeyConditionExpression: '#stage_id  = :stage_id',
						ExpressionAttributeNames: { '#stage_id': 'stage_id' },
						ExpressionAttributeValues: { ':stage_id': new_id },
					};
					let stage = await queryDynamo(checkIfStageExists);
					if (stage.Count == 0) {
						check_stage_exists = false;
						new_stage_id = new_id;
					}
				}
				await recreateStages(project_name, old_library_id, allStages[i].stage_id, new_library_id, new_stage_id, project_id, action);
			}
		}
		else {
			console.log('No Stages found for this library');
			return 'Success';
		}
	}
	else {
		console.log('Library Not Found while recreating');
		return 'Success';
	}
};

exports.handler = async (event) => {
	console.log(JSON.stringify(event));
	if (event.Records[0].dynamodb.Keys.project_id != undefined) {
		console.log('XcelAudit_Projects Table');
		for (let i = 0; i < event.Records.length; i++) {
			if (event.Records[i].eventName == 'INSERT' && event.Records[i].dynamodb.NewImage.project_status.S == 'UNDER_CREATION') {
				let project_name = event.Records[i].dynamodb.NewImage.project_name.S;
				await recreateLibrary(project_name, event.Records[i].dynamodb.NewImage.selected_template_id.S, event.Records[i].dynamodb.NewImage.general_template_id.S, event.Records[i].dynamodb.Keys.project_id.S, 'CREATING_PROJECT');
				let updateProjectStatus = {
					TableName: 'XcelAudit_Projects',
					Key: {
						project_id: event.Records[i].dynamodb.Keys.project_id.S,
					},
					UpdateExpression: 'SET project_status = :project_status',
					ExpressionAttributeValues: {
						':project_status': 'TO_BE_STARTED'
					},
					ReturnValues: 'UPDATED_NEW',
				};
				await updateDynamoRecord(updateProjectStatus);
				let updateOldLibrayParams = {
					TableName: 'XcelAudit_AuditLibraries',
					Key: {
						audit_library_id: event.Records[i].dynamodb.NewImage.general_template_id.S,
					},
					UpdateExpression: 'SET is_used = :is_used',
					ExpressionAttributeValues: {
						':is_used': false
					},
					ReturnValues: 'UPDATED_NEW',
				};
				await updateDynamoRecord(updateOldLibrayParams);
				return 'Success';
			}
		}
	}
	else if (event.Records[0].dynamodb.Keys.audit_library_id != undefined) {
		console.log('AUDIT LIBRARY TABLE');
		for (let i = 0; i < event.Records.length; i++) {
			if (event.Records[i].eventName == 'INSERT' && event.Records[i].dynamodb.NewImage.audit_library_status.S == 'UN_PUBLISHING') {
				await recreateLibrary("", event.Records[i].dynamodb.Keys.audit_library_id.S, event.Records[i].dynamodb.NewImage.parent_library_id.S, null, 'UNPUBLISHING');
				let updateLibraryStatus = {
					TableName: 'XcelAudit_AuditLibraries',
					Key: {
						audit_library_id: event.Records[i].dynamodb.Keys.audit_library_id.S,
					},
					UpdateExpression: 'set audit_library_status = :audit_library_status',
					ExpressionAttributeValues: {
						':audit_library_status': 'DRAFT'
					},
					ReturnValues: 'UPDATED_NEW',
				};
				await updateDynamoRecord(updateLibraryStatus);
				return 'Success';
			}
		}
	}
};
