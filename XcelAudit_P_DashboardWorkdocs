var AWS = require('aws-sdk');
AWS.config.update({ region: 'ap-south-1' });
var docClient = new AWS.DynamoDB.DocumentClient();
var lambda = new AWS.Lambda();

function invoke_lambda(payload, function_name, callbackFunction) {
    var params = {
        FunctionName: function_name,
        InvocationType: 'RequestResponse',
        Payload: JSON.stringify(payload),
    };
    var response = lambda.invoke(params, function(err, data) {
        if (err) {
            console.log(err, 'inside invoke_lambda: could not invoke: error stack: ' + err.stack);
        }
        else {
            if (typeof callbackFunction == 'function') callbackFunction(data);
        }
    });
}

function logErrorMsg(errMsg, params, stack, callback, callbackFn) {
    var msg = 'Lambda function name :' + process.env.AWS_LAMBDA_FUNCTION_NAME + '\n\nError message : \n' + JSON.stringify(errMsg) + '\n\nParams : \n' + JSON.stringify(params) + '\n\nStack : \n' + JSON.stringify(stack) + '\n\n Cloudwatch stream :' + process.env.AWS_LAMBDA_LOG_STREAM_NAME;
    invoke_lambda({ message: msg }, 'XcelAudit_B_P_ErrorLogs', function(data) {
        callback(errMsg);
    });
}

function queryDynamo(params, callback, callbackFn) {
    docClient.query(params, function(err, data) {
        if (err) {
            logErrorMsg(err, params, err.stack, callback, function(data) {
                callback(err);
            });
        }
        else {
            if (typeof callbackFn === 'function') {
                callbackFn(data);
            }
        }
    });
}

function getAllStepsForUserInProject(user_id, project_id, ExclusiveStartKey, steps, callback) {
    let params = {
        TableName: 'XcelAudit_AssignedSteps',
        IndexName: 'project_id-index',
        KeyConditionExpression: 'project_id = :project_id',
        FilterExpression: '#user_id = :user_id OR reviewer_user_id = :reviewer_user_id',
        ExpressionAttributeNames: { '#user_id': 'user_id' },
        ExpressionAttributeValues: {
            ':user_id': user_id,
            ':project_id': project_id,
            ':reviewer_user_id': user_id,
        },
        ExclusiveStartKey: ExclusiveStartKey,
    };
    return new Promise(function(resolve, reject) {
        docClient.query(params, function(err, data) {
            if (err) {
                console.log(params, err);
                logErrorMsg(err, params, err.stack, callback, function(data) {
                    reject(err);
                });
            }
            else {
                if (steps.Items != null) {
                    steps.Items.push(...data.Items);
                    steps.Count += data.Count;
                }
                else {
                    steps.Items = data.Items;
                    steps.Count += data.Count;
                }
                var response = {
                    Count: steps.Count,
                    Items: steps.Items,
                    LastEvaluatedKey: data.LastEvaluatedKey,
                };
                if (data.LastEvaluatedKey != undefined && data.LastEvaluatedKey != null) {
                    resolve(getAllStepsForUserInProject(user_id, project_id, data.LastEvaluatedKey, response, callback));
                }
                else {
                    resolve(response);
                }
            }
        });
    });
}

function showProjectDashBoard(event, context, callback) {
    if (event.user_id.trim().length > 0) {
        let getUserDetailsParams = {
            TableName: 'XcelAudit_UserPortal_Users',
            KeyConditionExpression: '#user_id = :user_id',
            ExpressionAttributeNames: { '#user_id': 'user_id' },
            ExpressionAttributeValues: { ':user_id': event.user_id },
        };
        queryDynamo(getUserDetailsParams, callback, function(user) {
            if (user.Count > 0) {
                let user_projects = user.Items[0].projects;
                if (user_projects.length > 0) {
                    let projectResponse = {
                        TO_BE_STARTED: 0,
                        IN_PROGRESS: 0,
                        COMPLETED: 0,
                        ARCHIVED: 0,
                    };
                    let tasksResponse = {};
                    let all_promises = user_projects.map((project_id) => {
                        let getProjectDetails = {
                            TableName: 'XcelAudit_Projects',
                            KeyConditionExpression: '#project_id = :project_id',
                            ExpressionAttributeNames: { '#project_id': 'project_id' },
                            ExpressionAttributeValues: { ':project_id': project_id },
                        };
                        let project_details = docClient.query(getProjectDetails).promise();
                        return project_details
                            .then((project) => {
                                if (project.Count > 0) {
                                    projectResponse[project.Items[0].project_status] += 1
                                    // for (const status in projectResponse) {
                                    //     if (status == project.Items[0].project_status) {
                                    //         projectResponse[status] = projectResponse[status] + 1;
                                    //     }
                                    // }
                                    tasksResponse[project.Items[0].project_name] = 0;
                                    let steps = getAllStepsForUserInProject(event.user_id, project.Items[0].project_id, null, { Items: null, Count: 0 }, callback);
                                    return steps.then((steps) => {
                                        tasksResponse[project.Items[0].project_name] = steps.Count;
                                    });
                                }
                                // else {
                                //     throw new Error('Project With ID ' + project_id + 'Not Found');
                                // }
                            })
                            .catch((err) => {
                                throw new Error(err);
                            });
                    });
                    Promise.all(all_promises)
                        .then((data) => {
                            let response = {};
                            response.items = {};
                            response.items.projectResponse = projectResponse;
                            response.items.tasksResponse = tasksResponse;
                            callback(null, { status: 'SUCCESS', data: response });
                        })
                        .catch((err) => {
                            callback(new Error(err));
                        });
                }
                else {
                    callback(new Error('No Data Found for the current user!!!'));
                }
            }
            else {
                callback(new Error('User Not Found with the ID: ' + event.user_id));
            }
        });
    }
    else {
        callback(new Error('Kindly,Enter User ID to list Dashbard Details Of the User'));
    }
}

function showQueriesDashBoard(event, context, callback) {
    if (event.user_id.trim().length > 0) {
        let getUserDetailsParams = {
            TableName: 'XcelAudit_UserPortal_Users',
            KeyConditionExpression: '#user_id = :user_id',
            ExpressionAttributeNames: { '#user_id': 'user_id' },
            ExpressionAttributeValues: { ':user_id': event.user_id },
        };
        queryDynamo(getUserDetailsParams, callback, function(user) {
            if (user.Count > 0) {
                let user_projects = user.Items[0].projects;
                let no_of_projects = user_projects.length;
                if (user_projects.length > 0) {
                    let queriesResponse = {
                        queries_raised_by_me: {
                            pending: 0,
                            resolved: 0,
                        },
                        queries_raised_by_others: {
                            pending: 0,
                            resolved: 0,
                        },
                    };
                    let promise_array = [];
                    for (let i = 0; i < user_projects.length; i++) {
                        promise_array.push(
                            new Promise((resolve, reject) => {
                                let getProjectDetails = {
                                    TableName: 'XcelAudit_Projects',
                                    KeyConditionExpression: '#project_id = :project_id',
                                    ExpressionAttributeNames: { '#project_id': 'project_id' },
                                    ExpressionAttributeValues: { ':project_id': user_projects[i] },
                                };
                                queryDynamo(getProjectDetails, callback, function(project) {
                                    if (project.Count > 0) {
                                        let getQueriesForUser = {
                                            TableName: 'XcelAudit_Queries',
                                            IndexName: 'project_id-index',
                                            KeyConditionExpression: '#project_id = :project_id',
                                            ExpressionAttributeNames: { '#project_id': 'project_id' },
                                            ExpressionAttributeValues: { ':project_id': user_projects[i] },
                                        };
                                        queryDynamo(getQueriesForUser, callback, function(Queries) {
                                            let project_queries = Queries.Items;
                                            for (let i = 0; i < project_queries.length; i++) {
                                                if (project_queries[i].case_owner == event.user_id) {
                                                    if (project_queries[i].query_status == 'PENDING') {
                                                        queriesResponse.queries_raised_by_me.pending += 1;
                                                    }
                                                    else {
                                                        queriesResponse.queries_raised_by_me.resolved += 1;
                                                    }
                                                }
                                                else {
                                                    let rised_to_users = project_queries[i].rised_to_user_id;
                                                    for (let j = 0; j < rised_to_users.length; j++) {
                                                        if (rised_to_users[j] == event.user_id) {
                                                            if (project_queries[i].query_status == 'PENDING') {
                                                                queriesResponse.queries_raised_by_others.pending += 1;
                                                            }
                                                            else {
                                                                queriesResponse.queries_raised_by_others.resolved += 1;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                            resolve("Success");
                                        });
                                    }
                                });
                            })
                        );
                    }
                    Promise.all(promise_array).then(data => {
                        let response = {
                            items: {
                                queriesResponse: queriesResponse
                            }
                        };
                        callback(null, { status: 'SUCCESS', data: response });
                    });
                }
                else {
                    callback(new Error('No Data Found for the current user!!!'));
                }
            }
            else {
                callback(new Error('User Not Found with the ID: ' + event.user_id));
            }
        });
    }
    else {
        callback(new Error('Kindly, Add User ID To List Dashboard Details'));
    }
}

function showTimeSheetDashBoard(event, context, callback) {
    if (event.user_id.trim().length != 0) {
        let getLogsDetails = {
            TableName: 'XcelAudit_Timesheets',
            IndexName: 'user_id-index',
            KeyConditionExpression: '#user_id = :user_id',
            ExpressionAttributeNames: { '#user_id': 'user_id' },
            ExpressionAttributeValues: { ':user_id': event.user_id },
        };
        queryDynamo(getLogsDetails, callback, function(Logs) {
            let response = {};
            let dataToSend = {
                APPROVED: 0,
                REJECTED: 0,
                PENDING: 0,
            };
            for (let i = 0; i < Logs.Items.length; i++) {
                dataToSend[Logs.Items[i].status] += 1;
                // else if (Logs.Items[i].status == 'REJECTED') {
                //     dataToSend.REJECTED = dataToSend.REJECTED + 1;
                // }
                // else {
                //     dataToSend.PENDING = dataToSend.PENDING + 1;
                // }
            }
            response.Items = dataToSend;
            callback(null, {
                status: 'SUCCESS',
                data: response,
            });
        });
    }
    else {
        callback(new Error('Kindly Enter User ID to list Audit Logs'));
    }
}

function listWorkdocs(event, context, callback) {
    if (event.user_id.trim().length != 0) {
        let getUserDetails = {
            TableName: 'XcelAudit_UserPortal_Users',
            KeyConditionExpression: '#user_id = :user_id',
            ExpressionAttributeNames: { '#user_id': 'user_id' },
            FilterExpression: 'user_system_status = :user_system_status AND user_type = :user_type',
            ExpressionAttributeValues: {
                ':user_id': event.user_id,
                ':user_system_status': 'ACTIVE',
                ':user_type': 'INTERNAL'
            },
        };
        queryDynamo(getUserDetails, callback, function(Users) {
            if (Users.Count > 0) {
                let user_projects = Users.Items[0].projects;
                if (user_projects.length > 0) {
                    let projectsToGet = [];
                    let projects_to_show = [];
                    let total_project_count = user_projects.length;
                    user_projects.forEach((project_id) => {
                        let getProjectDetails = {
                            TableName: 'XcelAudit_Projects',
                            KeyConditionExpression: '#project_id = :project_id',
                            FilterExpression: 'project_status <> :project_status',
                            ExpressionAttributeNames: { '#project_id': 'project_id' },
                            ExpressionAttributeValues: { ':project_id': project_id, ':project_status': 'ARCHIVED' },
                        };
                        queryDynamo(getProjectDetails, callback, function(project) {
                            total_project_count = total_project_count - 1;
                            if (project.Count > 0) {
                                projectsToGet.push(project.Items[0]);
                            }
                            if (total_project_count == 0) {
                                let project_promises = projectsToGet.map((project) => {
                                    let getAllStepsForProjects = {
                                        TableName: 'XcelAudit_AssignedSteps',
                                        IndexName: 'project_id-index',
                                        KeyConditionExpression: 'project_id = :project_id',
                                        FilterExpression: '#user_id = :user_id OR reviewer_user_id = :reviewer_user_id',
                                        ExpressionAttributeNames: { '#user_id': 'user_id' },
                                        ExpressionAttributeValues: {
                                            ':user_id': event.user_id,
                                            ':project_id': project.project_id,
                                            ':reviewer_user_id': event.user_id,
                                        },
                                    };
                                    let steps = docClient.query(getAllStepsForProjects).promise();
                                    return steps
                                        .then((steps) => {
                                            if (steps.Count > 0) {
                                                let master_steps = [];
                                                for (let i = 0; i < steps.Items.length; i++) {
                                                    console.log(steps.Items[i]);
                                                    if (steps.Items[i].uploaded_url && steps.Items[i].uploaded_url.length > 0) {
                                                        master_steps.push(steps.Items[i]);
                                                    }
                                                }
                                                let stages_array = [];
                                                if (master_steps.length > 0) {
                                                    [...new Set(master_steps.map((obj) => obj.stage_id))].forEach((stage_id) => {
                                                        let sub_stages = [];
                                                        let filterSubStages = [...new Set(master_steps.filter((obj) => obj.stage_id == stage_id))];
                                                        [...new Set(filterSubStages.map((obj) => obj.sub_stage_id))].forEach((sub_stage_id) => {
                                                            let filteredSteps = [...new Set(master_steps.filter((obj) => obj.sub_stage_id == sub_stage_id))];
                                                            let new_steps = [...new Set(filteredSteps.map((obj) => obj.step_id))];
                                                            sub_stages.push({
                                                                sub_stage_id: sub_stage_id,
                                                                steps: new_steps,
                                                            });
                                                        });
                                                        stages_array.push({
                                                            stage_id: stage_id,
                                                            sub_stages: sub_stages,
                                                        });
                                                    });
                                                    project.stages = stages_array;
                                                    projects_to_show.push(project);
                                                }
                                            }
                                        })
                                        .catch((err) => {
                                            throw new Error(err);
                                        });
                                });
                                Promise.all(project_promises)
                                    .then((data) => {
                                        if (projects_to_show.length > 0) {
                                            let client_id = [];
                                            let clients_to_show = [];

                                            for (let project of projects_to_show) {
                                                if (client_id.includes(project.client_id)) {
                                                    clients_to_show.map(client => {
                                                        if (client.client_id == project.client_id) {
                                                            client.projects.push(project);
                                                        }
                                                        return client;
                                                    });
                                                }
                                                else {
                                                    client_id.push(project.client_id);
                                                    clients_to_show.push({
                                                        client_id: project.client_id,
                                                        client_name: project.client_name,
                                                        projects: [project]
                                                    });
                                                }
                                            }
                                            callback(null, clients_to_show);
                                        }
                                        else {
                                            callback(new Error('Currently There Are No Workdocs Pending On You'));
                                        }
                                    })
                                    .catch((err) => {
                                        callback(new Error(err));
                                    });
                            }
                        });
                    });
                }
                else {
                    callback(new Error('You Dont Have Any Workdocs Pending On You!!'));
                }
            }
            else {
                callback(new Error('User With ID: ' + event.user_id + ' not found'));
            }
        });
    }
}

exports.handler = (event, context, callback) => {
    console.log(event);
    switch (event.command) {
        case 'showProjectDashBoard':
            showProjectDashBoard(event, context, callback);
            break;
        case 'showQueriesDashBoard':
            showQueriesDashBoard(event, context, callback);
            break;
        case 'showTimeSheetDashBoard':
            showTimeSheetDashBoard(event, context, callback);
            break;
        case 'listWorkdocs':
            listWorkdocs(event, context, callback);
            break;
        default:
            callback(new Error('Command not found'));
    }
};

// function showProjectDashBoard(event, context, callback) {
//     if (event.user_id.trim().length > 0) {
//         let getUserDetailsParams = {
//             TableName: "XcelAudit_UserPortal_Users",
//             KeyConditionExpression: '#user_id = :user_id',
//             ExpressionAttributeNames: { '#user_id': "user_id" },
//             ExpressionAttributeValues: { ':user_id': event.user_id }
//         };
//         queryDynamo(getUserDetailsParams, callback, function(user) {
//             if (user.Count > 0) {
//                 let user_projects = user.Items[0].projects;
//                 let no_of_projects = user_projects.length;
//                 if (user_projects.length > 0) {
//                     let projectResponse = {
//                         TO_BE_STARTED: 0,
//                         IN_PROGRESS: 0,
//                         COMPLETED: 0,
//                         ARCHIVED: 0
//                     };
//                     let tasksResponse = {};
//                     user_projects.forEach(project_id => {
//                         let getProjectDetails = {
//                             TableName: "XcelAudit_Projects",
//                             KeyConditionExpression: '#project_id = :project_id',
//                             ExpressionAttributeNames: { '#project_id': "project_id" },
//                             ExpressionAttributeValues: { ':project_id': project_id }
//                         };
//                         queryDynamo(getProjectDetails, callback, function(project) {
//                             no_of_projects = no_of_projects - 1;
//                             if (project.Count > 0) {
//                                 for (const status in projectResponse) {
//                                     if (status == project.Items[0].project_status) {
//                                         projectResponse[status] = projectResponse[status] + 1;
//                                     }
//                                 }
//                                 tasksResponse[project.Items[0].project_name] = 0;
//                                 let total_tasks_pending = 0;
//                                 for (let item in project.Items[0].selected_template.audit_library_stages) {
//                                     let singleStage = project.Items[0].selected_template.audit_library_stages[item];
//                                     for (let element in singleStage.sub_stages) {
//                                         let singleSubStage = singleStage.sub_stages[element];
//                                         for (let key in singleSubStage.steps) {
//                                             let singleStep = singleSubStage.steps[key];
//                                             if (singleStep.assigned_to_user_id != undefined) {
//                                                 if (singleStep.assigned_to_user_id.includes(event.user_id) || singleStep.reviewer_user_id) {
//                                                     total_tasks_pending = total_tasks_pending + 1;
//                                                 }
//                                             }
//                                         }
//                                     }
//                                 }
//                                 tasksResponse[project.Items[0].project_name] = total_tasks_pending;
//                             }
//                             if (no_of_projects == 0) {
//                                 let response = {};
//                                 response.items = {};
//                                 response.items.projectResponse = projectResponse;
//                                 response.items.tasksResponse = tasksResponse;
//                                 callback(null, { "status": "SUCCESS", data: response });
//                             }
//                         });
//                     });
//                 }
//                 else {
//                     callback(new Error("No Data Found for the current user!!!"));
//                 }
//             }
//             else {
//                 callback(new Error("User Not Found with the ID: " + event.user_id));
//             }
//         });
//     }
//     else {
//         callback(new Error("Kindly,Enter User ID to list Dashbard Details Of the User"));
//     }
// }

// function listWorkdocs(event, context, callback) {
//     if (event.user_id.trim().length != 0) {
//         let getUserDetails = {
//             TableName: "XcelAudit_UserPortal_Users",
//             KeyConditionExpression: '#user_id = :user_id',
//             ExpressionAttributeNames: { '#user_id': "user_id" },
//             FilterExpression: "user_system_status = :user_system_status AND user_type = :user_type",
//             ExpressionAttributeValues: {
//                 ':user_id': event.user_id,
//                 ':user_system_status': "ACTIVE",
//                 ':user_type': "INTERNAL"
//             }
//         };
//         queryDynamo(getUserDetails, callback, function(Users) {
//             if (Users.Count > 0) {
//                 let user_projects = Users.Items[0].projects;
//                 if (user_projects.length > 0) {
//                     let projectstoShow = [];
//                     let client_data = {};
//                     let total_project_count = user_projects.length;
//                     user_projects.forEach(project_id => {
//                         let getProjectDetails = {
//                             TableName: "XcelAudit_Projects",
//                             KeyConditionExpression: '#project_id = :project_id',
//                             ExpressionAttributeNames: { '#project_id': "project_id" },
//                             ExpressionAttributeValues: { ':project_id': project_id }
//                         };
//                         queryDynamo(getProjectDetails, callback, function(project) {
//                             total_project_count = total_project_count - 1;
//                             if (project.Count > 0) {
//                                 for (let item in project.Items[0].selected_template.audit_library_stages) {
//                                     let singleStage = project.Items[0].selected_template.audit_library_stages[item];
//                                     for (let element in singleStage.sub_stages) {
//                                         let singleSubStage = singleStage.sub_stages[element];
//                                         for (let key in singleSubStage.steps) {
//                                             let singleStep = singleSubStage.steps[key];
//                                             if (singleStep.assigned_to_user_id != undefined) {
//                                                 if (singleStep.reviewer_user_id == event.user_id && singleStep.uploaded_url.length > 0) {

//                                                 }
//                                                 else if (singleStep.assigned_to_user_id.includes(event.user_id) && singleStep.uploaded_url.length > 0) {

//                                                 }
//                                                 else {
//                                                     delete singleSubStage.steps[key];
//                                                 }
//                                             }
//                                             else {
//                                                 delete singleSubStage.steps[key];
//                                             }
//                                         }
//                                         if (Object.keys(singleSubStage.steps).length == 0) {
//                                             delete project.Items[0].selected_template.audit_library_stages[item].sub_stages[singleSubStage.sub_stage_name];
//                                         }
//                                     }
//                                     if (Object.keys(singleStage.sub_stages).length == 0) {
//                                         delete project.Items[0].selected_template.audit_library_stages[item];
//                                     }
//                                 }
//                                 if (Object.keys(project.Items[0].selected_template.audit_library_stages).length > 0) {
//                                     if (client_data.hasOwnProperty(project.Items[0].client_name)) {
//                                         client_data[project.Items[0].client_name][project.Items[0].project_name] = project.Items[0];
//                                     }
//                                     else {
//                                         client_data[project.Items[0].client_name] = {};
//                                         client_data[project.Items[0].client_name][project.Items[0].project_name] = project.Items[0];
//                                     }
//                                 }
//                             }
//                             if (total_project_count == 0) {
//                                 if (Object.keys(client_data).length > 0) {
//                                     let response = {};
//                                     response.items = client_data;
//                                     callback(null, {
//                                         "status": "SUCCESS",
//                                         data: response
//                                     });
//                                 }
//                                 else {
//                                     callback(new Error("Currently there are no workdocs to list for you"));
//                                 }
//                             }
//                         });
//                     });
//                 }
//                 else {
//                     callback(new Error("Currently there are no workdocs to list for you"));
//                 }
//             }
//             else {
//                 callback(new Error("No ACTIVE INTERNAL User was found With ID: " + event.user_id));
//             }
//         });
//     }
//     else {
//         callback(new Error("Kindly Enter User ID to list Workdocs"));
//     }
// }
