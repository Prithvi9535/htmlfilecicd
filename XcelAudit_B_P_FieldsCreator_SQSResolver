var AWS = require('aws-sdk');
var docClient = new AWS.DynamoDB.DocumentClient();
var uuid = require('uuid');
var sqs = new AWS.SQS();

async function invokeSQS(body) {
    try {
        let sqs_params = {
            MessageBody: JSON.stringify(body),
            QueueUrl: "https://sqs.ap-south-1.amazonaws.com/157247043770/XcelAudit_FieldsCreator"
        };
        // console.log(body);
        await sqs.sendMessage(sqs_params).promise();
        return "Successfully Invoked";
    }
    catch (err) {
        console.log(body)
        console.log("INVOKING SQS ERROR", err);
    }
}


function logErrorMsg(errMsg, params, stack, callback, callbackFn) {
    var msg = 'Lambda function name :' + process.env.AWS_LAMBDA_FUNCTION_NAME + '\n\nError message : \n' + JSON.stringify(errMsg) + '\n\nParams : \n' + JSON.stringify(params) + '\n\nStack : \n' + JSON.stringify(stack) + '\n\n Cloudwatch stream :' + process.env.AWS_LAMBDA_LOG_STREAM_NAME;
    callback(errMsg);
    console.log(params, errMsg, msg);
}

//DYNAMO APIS
const queryDynamo = async params => {
    try {
        let data = await docClient.query(params).promise();
        return data;
    }
    catch (err) {
        console.log(params, err);
        throw new Error(err);
    }
};

const scanDynamo = async params => {
    try {
        let data = await docClient.scan(params).promise();
        return data;
    }
    catch (err) {
        console.log(params, err);
        throw new Error(err);
    }
};

const insertIntoDynamo = async params => {
    try {
        await docClient.put(params).promise();
        return 'Success';
    }
    catch (err) {
        console.log(params, err);
        throw new Error(err);
    }
};

const updateDynamoRecord = async params => {
    try {
        await docClient.update(params).promise();
        return 'Success';
    }
    catch (err) {
        console.log(params, err);
        throw new Error(err);
    }
};

const deleteFromDynamo = async params => {
    try {
        await docClient.delete(params).promise();
        return 'Success';
    }
    catch (err) {
        console.log(params, err);
        throw new Error(err);
    }
}

const wait = ms => new Promise(res => setTimeout(res, ms));

const batchDynamoOperation = async (params, retryCount = 0) => {
    try {
        let res = await docClient.batchWrite(params).promise();
        if (res.UnprocessedItems && res.UnprocessedItems.length > 0) {
            console.log(`${res.UnprocessedItems.length} unprocessed item(s) left, retrying...`);
            if (retryCount > 2) {
                throw new Error(res.UnprocessedItems);
            }
            await wait(2 ** retryCount * 10);
            return batchDynamoOperation(res.UnprocessedItems, retryCount + 1);
        }
        return 'Success';
    }
    catch (err) {
        console.log(JSON.stringify(params), err);
        throw new Error(err);
    }
};

const s3GetObject = async params => {
    try {
        let s3 = new AWS.S3();
        const data = JSON.parse((await s3.getObject(params).promise()).Body.toString('utf-8'));
        return {
            status: 'Success',
            data
        };
    }
    catch (err) {
        console.log(err);
        return {
            status: 'Error'
        };
    }
};

exports.handler = async event => {
    let single_step = JSON.parse(event.Records[0].body);
    console.log(single_step);
    if (single_step.work_docs_type == 'FormBasedStep') {
        let access_granted = false;
        let s3data;
        let fields_to_create_25Each = [];
        if (single_step.old_template_id) {
            let getFieldsOfForm = {
                TableName: 'XcelAudit_Steps_FormFields',
                IndexName: 'step_id-sub_stage_id-index',
                KeyConditionExpression: '#step_id = :step_id AND #sub_stage_id = :sub_stage_id',
                ExpressionAttributeNames: {
                    '#step_id': 'step_id',
                    '#sub_stage_id': 'sub_stage_id'
                },
                ExpressionAttributeValues: {
                    ':step_id': single_step.old_step_id,
                    ':sub_stage_id': single_step.old_sub_stage_id
                }
            };
            let queryData = await queryDynamo(getFieldsOfForm);
            while (queryData.Items.length) {
                fields_to_create_25Each.push(queryData.Items.splice(0, 25));
            }
            access_granted = true;
        }
        else {
            s3data = await s3GetObject({ Bucket: 'xcel-audit-documents', Key: single_step.s3_key });
            if (s3data.status == 'Success') {
                console.log(s3data);
                while (s3data.data.length) {
                    fields_to_create_25Each.push(s3data.data.splice(0, 25));
                }
                access_granted = true;
            }
        }
        if (access_granted) {
            for (let d = 0; d < fields_to_create_25Each.length; d++) {
                let batchWriteParams = {
                    RequestItems: {
                        XcelAudit_Steps_FormFields: []
                    }
                };
                for (let j = 0; j < fields_to_create_25Each[d].length; j++) {
                    let singleFieldObj = fields_to_create_25Each[d][j];
                    let Item = {};
                    for (const field in singleFieldObj) {
                        if (field == 'field_id') {
                            Item[field] = singleFieldObj[field].toString();
                        }
                        else if (field == 'field_sub_fields') {
                            let sub_fields = singleFieldObj[field];
                            for (let i = 0; i < sub_fields.length; i++) {
                                let item = {};
                                let single_sub_field = sub_fields[i];
                                for (const field in single_sub_field) {
                                    if (field == 'field_id' || field == 'sub_field_id') {
                                        item['field_id'] = singleFieldObj['field_id'].toString() + '__' + single_sub_field[field].toString();
                                        item['step_id__field_id'] = single_step.step_id + '__' + singleFieldObj.field_id.toString() + '__' + single_sub_field[field].toString();
                                    }
                                    else if (field == 'field_name') {
                                        item['field_name'] = single_sub_field[field];
                                    }
                                    else if (field == 'field_sub_sub_fields') {
                                        let sub_sub_fields = single_sub_field[field];
                                        for (let j = 0; j < sub_sub_fields.length; j++) {
                                            let item = {};
                                            let single_sub_sub_field = sub_sub_fields[j];
                                            for (const field in single_sub_sub_field) {
                                                if (field == 'field_id' || field == 'sub_field_id') {
                                                    item['field_id'] = singleFieldObj['field_id'].toString() + '__' + single_sub_field['field_id'] + '__' + single_sub_sub_field[field];
                                                    item['step_id__field_id'] = single_step.step_id + '__' + singleFieldObj['field_id'].toString() + '__' + single_sub_field['field_id'] + '__' + single_sub_sub_field[field];
                                                }
                                                else if (field == 'field_name') {
                                                    item['field_name'] = single_sub_sub_field[field];
                                                }
                                                else {
                                                    item[field] = single_sub_sub_field[field];
                                                }
                                            }
                                            item['audit_library_id'] = single_step.audit_library_id;
                                            item['stage_id'] = single_step.stage_id;
                                            item['sub_stage_id'] = single_step.sub_stage_id;
                                            item['step_id'] = single_step.step_id;
                                            item['form_id'] = single_step.form_id;
                                            item['field_configured'] = false;
                                            if (single_step.form_name != 'BasicFinancialData.json') {
                                                item['internal_field_type'] = 'GRAND_CHILD';
                                            }
                                            item['applicable'] = true;
                                            let subfieldParams = {
                                                Item: item,
                                                TableName: 'XcelAudit_Steps_FormFields',
                                                ReturnValues: 'ALL_OLD'
                                            };
                                            await insertIntoDynamo(subfieldParams);
                                        }
                                    }
                                    else {
                                        item[field] = single_sub_field[field];
                                    }
                                }
                                item['audit_library_id'] = single_step.audit_library_id;
                                item['stage_id'] = single_step.stage_id;
                                item['sub_stage_id'] = single_step.sub_stage_id;
                                item['step_id'] = single_step.step_id;
                                item['form_id'] = single_step.form_id;
                                item['field_configured'] = false;
                                item['internal_field_type'] = 'CHILD';
                                item['applicable'] = true;
                                let subfieldParams = {
                                    Item: item,
                                    TableName: 'XcelAudit_Steps_FormFields',
                                    ReturnValues: 'ALL_OLD'
                                };
                                await insertIntoDynamo(subfieldParams);
                            }
                        }
                        else if (field == 'field_name') {
                            Item[field] = singleFieldObj[field];
                        }
                        else {
                            Item[field] = singleFieldObj[field];
                        }
                        Item['audit_library_id'] = single_step.audit_library_id;
                        Item['stage_id'] = single_step.stage_id;
                        Item['sub_stage_id'] = single_step.sub_stage_id;
                        Item['step_id'] = single_step.step_id;
                        if (singleFieldObj.internal_field_type) {
                            Item['internal_field_type'] = singleFieldObj.internal_field_type;
                        }
                        else if (!single_step.old_template_id && single_step.form_name != 'BasicFinancialData.json') {
                            Item['internal_field_type'] = 'PARENT';
                        }
                        Item['form_id'] = single_step.form_id;
                        Item['applicable'] = true;
                        Item['field_configured'] = singleFieldObj.field_configured ? singleFieldObj.field_configured : false;
                        Item['step_id__field_id'] = single_step.step_id + '__' + singleFieldObj.field_id.toString();
                    }
                    batchWriteParams.RequestItems.XcelAudit_Steps_FormFields.push({
                        PutRequest: {
                            Item: Item
                        }
                    });
                }
                console.log(JSON.stringify(batchWriteParams));
                await batchDynamoOperation(batchWriteParams);
                console.log('Batch Success');
            }
        }
    }
    else if (single_step.work_docs_type == 'ChecklistBasedStep') {
        let access_granted = false;
        let s3 = false;
        let s3data;
        let fields_to_create_25Each = [];
        if (single_step.old_template_id) {
            let getFieldsOfForm = {
                TableName: 'XcelAudit_Steps_FormFields',
                IndexName: 'step_id-sub_stage_id-index',
                KeyConditionExpression: '#step_id = :step_id AND #sub_stage_id = :sub_stage_id',
                ExpressionAttributeNames: {
                    '#step_id': 'step_id',
                    '#sub_stage_id': 'sub_stage_id'
                },
                ExpressionAttributeValues: {
                    ':step_id': single_step.old_step_id,
                    ':sub_stage_id': single_step.old_sub_stage_id
                }
            };
            let queryData = await queryDynamo(getFieldsOfForm);
            while (queryData.Items.length) {
                fields_to_create_25Each.push(queryData.Items.splice(0, 25));
            }
            access_granted = true;
        }
        else {
            s3data = await s3GetObject({ Bucket: 'xcel-audit-documents', Key: single_step.s3_key });
            if (s3data.status == 'Success') {
                while (s3data.data.CheckListArray.length) {
                    fields_to_create_25Each.push(s3data.data.CheckListArray.splice(0, 25));
                }
                access_granted = true;
                s3 = true;
            }
        }
        if (access_granted) {
            for (let d = 0; d < fields_to_create_25Each.length; d++) {
                let batchWriteParams = {
                    RequestItems: {
                        XcelAudit_Steps_FormFields: []
                    }
                };
                for (let j = 0; j < fields_to_create_25Each[d].length; j++) {
                    let singleFieldObj = fields_to_create_25Each[d][j];
                    let Item = {};
                    for (const field in singleFieldObj) {
                        Item[field] = singleFieldObj[field];
                    }
                    Item['audit_library_id'] = single_step.audit_library_id;
                    Item['stage_id'] = single_step.stage_id;
                    Item['sub_stage_id'] = single_step.sub_stage_id;
                    Item['step_id'] = single_step.step_id;
                    Item['check_list_id'] = single_step.check_list_id;
                    if (!single_step.old_template_id) {
                        let field_id = uuid.v4();
                        Item['field_id'] = field_id;
                        Item['step_id__field_id'] = single_step.step_id + '__' + field_id;
                    }
                    else {
                        Item['step_id__field_id'] = single_step.step_id + '__' + singleFieldObj['field_id'];
                    }
                    batchWriteParams.RequestItems.XcelAudit_Steps_FormFields.push({
                        PutRequest: {
                            Item: Item
                        }
                    });
                }
                console.log(JSON.stringify(batchWriteParams));
                await batchDynamoOperation(batchWriteParams);
                console.log('Batch Success');
            }
            if (s3) {
                let updateAuditLibraryParams = {
                    TableName: 'XcelAudit_Library_Steps',
                    Key: {
                        step_id: single_step.step_id,
                        sub_stage_id: single_step.sub_stage_id
                    },
                    UpdateExpression: 'set #number_of_items = :number_of_items, global_tooltips = :global_tooltips, is_global_applicability_configured = :is_global_applicability_configured, global_applicability_rules = :global_applicability_rules,notapplicablity = :notapplicablity',
                    ExpressionAttributeNames: {
                        '#number_of_items': 'number_of_items'
                    },
                    ExpressionAttributeValues: {
                        ':number_of_items': s3data.data.number_of_items,
                        ':global_tooltips': s3data.data.global_tooltips,
                        ':is_global_applicability_configured': s3data.data.is_global_applicability_configured,
                        ':global_applicability_rules': s3data.data.global_applicability_rules,
                        ':notapplicablity': s3data.data.notapplicablity ? s3data.data.notapplicablity : false
                    },
                    ReturnValues: 'UPDATED_NEW'
                };
                await updateDynamoRecord(updateAuditLibraryParams);
            }
            else {
                let getParentStepData = {
                    TableName: 'XcelAudit_Library_Steps',
                    KeyConditionExpression: 'step_id = :step_id AND sub_stage_id = :sub_stage_id',
                    ExpressionAttributeValues: {
                        ':step_id': single_step.old_step_id,
                        ':sub_stage_id': single_step.old_sub_stage_id
                    }
                };
                let data = await queryDynamo(getParentStepData);
                let updateAuditLibraryParams = {
                    TableName: 'XcelAudit_Library_Steps',
                    Key: {
                        step_id: single_step.step_id,
                        sub_stage_id: single_step.sub_stage_id
                    },
                    UpdateExpression: 'set #number_of_items = :number_of_items, global_tooltips = :global_tooltips, is_global_applicability_configured = :is_global_applicability_configured, global_applicability_rules = :global_applicability_rules,notapplicablity = :notapplicablity',
                    ExpressionAttributeNames: {
                        '#number_of_items': 'number_of_items'
                    },
                    ExpressionAttributeValues: {
                        ':number_of_items': data.Items[0].number_of_items,
                        ':global_tooltips': data.Items[0].global_tooltips,
                        ':is_global_applicability_configured': data.Items[0].is_global_applicability_configured,
                        ':global_applicability_rules': data.Items[0].global_applicability_rules,
                        ':notapplicablity': data.Items[0].notapplicablity
                    },
                    ReturnValues: 'UPDATED_NEW'
                };
                await updateDynamoRecord(updateAuditLibraryParams);
            }
            return { status: 'Success', Status_Message: 'Created Stage successfully!!' };
        }
    }
    for (let i = 1; i < event.Records.length; i++) {
        await invokeSQS(event.Records[i].body);
    }
    return "Great Sucess";
};
